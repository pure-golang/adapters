
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pgx: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pure-golang/adapters/db/pg/pgx/config.go (100.0%)</option>
				
				<option value="file1">github.com/pure-golang/adapters/db/pg/pgx/errors.go (100.0%)</option>
				
				<option value="file2">github.com/pure-golang/adapters/db/pg/pgx/logger.go (94.4%)</option>
				
				<option value="file3">github.com/pure-golang/adapters/db/pg/pgx/pg.go (82.6%)</option>
				
				<option value="file4">github.com/pure-golang/adapters/db/pg/pgx/tracing.go (100.0%)</option>
				
				<option value="file5">github.com/pure-golang/adapters/db/pg/sqlx/connection.go (63.6%)</option>
				
				<option value="file6">github.com/pure-golang/adapters/db/pg/sqlx/errors.go (94.7%)</option>
				
				<option value="file7">github.com/pure-golang/adapters/db/pg/sqlx/queries.go (77.5%)</option>
				
				<option value="file8">github.com/pure-golang/adapters/db/pg/sqlx/tracing.go (100.0%)</option>
				
				<option value="file9">github.com/pure-golang/adapters/db/pg/sqlx/transaction.go (67.9%)</option>
				
				<option value="file10">github.com/pure-golang/adapters/env/env.go (100.0%)</option>
				
				<option value="file11">github.com/pure-golang/adapters/executor/cli/cli.go (0.0%)</option>
				
				<option value="file12">github.com/pure-golang/adapters/executor/cli/config.go (0.0%)</option>
				
				<option value="file13">github.com/pure-golang/adapters/executor/cli/metrics.go (50.0%)</option>
				
				<option value="file14">github.com/pure-golang/adapters/executor/cli/tracing.go (0.0%)</option>
				
				<option value="file15">github.com/pure-golang/adapters/grpc/errors/errors.go (100.0%)</option>
				
				<option value="file16">github.com/pure-golang/adapters/grpc/middleware/logging.go (100.0%)</option>
				
				<option value="file17">github.com/pure-golang/adapters/grpc/middleware/metrics.go (91.1%)</option>
				
				<option value="file18">github.com/pure-golang/adapters/grpc/middleware/monitoring.go (100.0%)</option>
				
				<option value="file19">github.com/pure-golang/adapters/grpc/middleware/tracing.go (100.0%)</option>
				
				<option value="file20">github.com/pure-golang/adapters/grpc/std/server.go (92.8%)</option>
				
				<option value="file21">github.com/pure-golang/adapters/httpserver/middleware/monitoring.go (98.0%)</option>
				
				<option value="file22">github.com/pure-golang/adapters/httpserver/middleware/recovery.go (100.0%)</option>
				
				<option value="file23">github.com/pure-golang/adapters/httpserver/std/server.go (91.3%)</option>
				
				<option value="file24">github.com/pure-golang/adapters/kv/kv.go (100.0%)</option>
				
				<option value="file25">github.com/pure-golang/adapters/kv/noop/noop.go (100.0%)</option>
				
				<option value="file26">github.com/pure-golang/adapters/kv/redis/client.go (83.9%)</option>
				
				<option value="file27">github.com/pure-golang/adapters/kv/redis/config.go (94.1%)</option>
				
				<option value="file28">github.com/pure-golang/adapters/kv/redis/errors.go (100.0%)</option>
				
				<option value="file29">github.com/pure-golang/adapters/kv/redis/logger.go (100.0%)</option>
				
				<option value="file30">github.com/pure-golang/adapters/kv/redis/tracing.go (90.0%)</option>
				
				<option value="file31">github.com/pure-golang/adapters/logger/devslog/devslog.go (100.0%)</option>
				
				<option value="file32">github.com/pure-golang/adapters/logger/logger.go (96.9%)</option>
				
				<option value="file33">github.com/pure-golang/adapters/logger/noop/noop.go (100.0%)</option>
				
				<option value="file34">github.com/pure-golang/adapters/logger/stdjson/stdjson.go (100.0%)</option>
				
				<option value="file35">github.com/pure-golang/adapters/mail/noop/noop.go (100.0%)</option>
				
				<option value="file36">github.com/pure-golang/adapters/mail/smtp/sender.go (77.0%)</option>
				
				<option value="file37">github.com/pure-golang/adapters/metrics/metrics.go (80.0%)</option>
				
				<option value="file38">github.com/pure-golang/adapters/metrics/prometheus.go (75.0%)</option>
				
				<option value="file39">github.com/pure-golang/adapters/queue/encoders/json.go (100.0%)</option>
				
				<option value="file40">github.com/pure-golang/adapters/queue/encoders/text.go (100.0%)</option>
				
				<option value="file41">github.com/pure-golang/adapters/queue/kafka/dialer.go (100.0%)</option>
				
				<option value="file42">github.com/pure-golang/adapters/queue/kafka/publisher.go (89.7%)</option>
				
				<option value="file43">github.com/pure-golang/adapters/queue/kafka/subscriber.go (89.7%)</option>
				
				<option value="file44">github.com/pure-golang/adapters/queue/kafka/tracing.go (100.0%)</option>
				
				<option value="file45">github.com/pure-golang/adapters/queue/queue.go (100.0%)</option>
				
				<option value="file46">github.com/pure-golang/adapters/queue/rabbitmq/constant_retry_policy.go (100.0%)</option>
				
				<option value="file47">github.com/pure-golang/adapters/queue/rabbitmq/dialer.go (90.2%)</option>
				
				<option value="file48">github.com/pure-golang/adapters/queue/rabbitmq/interval_retry_policy.go (100.0%)</option>
				
				<option value="file49">github.com/pure-golang/adapters/queue/rabbitmq/publisher.go (90.9%)</option>
				
				<option value="file50">github.com/pure-golang/adapters/queue/rabbitmq/subscriber.go (63.8%)</option>
				
				<option value="file51">github.com/pure-golang/adapters/queue/rabbitmq/tracing.go (100.0%)</option>
				
				<option value="file52">github.com/pure-golang/adapters/storage/errors.go (100.0%)</option>
				
				<option value="file53">github.com/pure-golang/adapters/storage/minio/client.go (91.7%)</option>
				
				<option value="file54">github.com/pure-golang/adapters/storage/minio/errors.go (100.0%)</option>
				
				<option value="file55">github.com/pure-golang/adapters/storage/minio/minio.go (100.0%)</option>
				
				<option value="file56">github.com/pure-golang/adapters/storage/minio/multipart.go (35.4%)</option>
				
				<option value="file57">github.com/pure-golang/adapters/storage/minio/presigned.go (69.7%)</option>
				
				<option value="file58">github.com/pure-golang/adapters/storage/minio/storage.go (53.5%)</option>
				
				<option value="file59">github.com/pure-golang/adapters/tracing/jaeger/jaeger.go (72.2%)</option>
				
				<option value="file60">github.com/pure-golang/adapters/tracing/tracing.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pgx

import (
        "fmt"
        "net/url"
)

type Config struct {
        User            string `envconfig:"POSTGRES_USER" required:"true"`
        Password        string `envconfig:"POSTGRES_PASSWORD" required:"true"`
        Host            string `envconfig:"POSTGRES_HOST" required:"true"`
        Port            int    `envconfig:"POSTGRES_PORT" default:"5432"`
        Name            string `envconfig:"POSTGRES_DB_NAME" required:"true"`
        CertPath        string `envconfig:"POSTGRES_SSL_CERT_PATH"`
        MaxOpenConns    int32  `envconfig:"POSTGRES_MAX_OPEN_CONNECTIONS" default:"20"`
        MaxConnLifeTime int32  `envconfig:"POSTGRES_MAX_CONNECTIONS_LIFETIME" default:"5"`
        MaxConnIdleTime int32  `envconfig:"POSTGRES_MAX_CONNECTIONS_IDLE_TIME" default:"5"`
        // TraceLogLevel  values: trace, debug, info, warn, error, none.
        // Set "error" or omit empty for production, "debug" for dev.
        TraceLogLevel string `envconfig:"POSTGRES_TRACE_LOG_LEVEL" default:"error"`
}

// URL returns database config in URL presentation
func (c *Config) URL() *url.URL <span class="cov10" title="35">{
        q := url.Values{"timezone": []string{"utc"}}
        if c.CertPath != "" </span><span class="cov2" title="2">{
                q.Set("sslmode", "verify-full")
                q.Set("sslrootcert", c.CertPath)
        }</span> else<span class="cov9" title="33"> {
                q.Set("sslmode", "disable")
        }</span>

        // Build host:port string
        <span class="cov10" title="35">host := c.Host
        if c.Port != 5432 </span><span class="cov8" title="19">{
                host = fmt.Sprintf("%s:%d", c.Host, c.Port)
        }</span>

        <span class="cov10" title="35">return &amp;url.URL{
                Scheme:   "postgres",
                User:     url.UserPassword(c.User, c.Password),
                Host:     host,
                Path:     c.Name,
                RawQuery: q.Encode(),
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package pgx

import (
        "github.com/jackc/pgconn"
        "github.com/pkg/errors"
)

// ErrorCode from https://www.postgresql.org/docs/current/errcodes-appendix.html
type ErrorCode string

const (
        UniqueViolation     ErrorCode = "23505"
        ForeignKeyViolation ErrorCode = "23503"
        CheckViolation      ErrorCode = "23514"
)

func (e ErrorCode) String() string <span class="cov7" title="8">{
        return string(e)
}</span>

// ErrorIs checks if error is *pgconn.PgError and compares codes
func ErrorIs(err error, code ErrorCode) (*pgconn.PgError, bool) <span class="cov10" title="17">{
        var pgErr *pgconn.PgError
        if !errors.As(err, &amp;pgErr) </span><span class="cov3" title="2">{
                return nil, false
        }</span>
        <span class="cov9" title="15">if pgErr.Code == string(code) </span><span class="cov7" title="8">{
                return pgErr, true
        }</span>
        <span class="cov7" title="7">return nil, false</span>
}

// FromError converts error to *pgconn.PgError if it's possible
func FromError(err error) (*pgconn.PgError, bool) <span class="cov6" title="6">{
        if err == nil </span><span class="cov1" title="1">{
                return nil, false
        }</span>
        <span class="cov6" title="5">var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) </span><span class="cov4" title="3">{
                return pgErr, true
        }</span>
        <span class="cov3" title="2">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package pgx

import (
        "context"
        "log/slog"
        "time"

        "github.com/pure-golang/adapters/logger"
        "github.com/jackc/pgx/v5/tracelog"
)

type Logger struct {
        minLevel tracelog.LogLevel
}

func NewLogger() *Logger <span class="cov7" title="17">{
        return &amp;Logger{}
}</span>

func (l *Logger) Log(ctx context.Context, level tracelog.LogLevel, msg string, data map[string]interface{}) <span class="cov8" title="27">{
        if level &lt; l.minLevel </span><span class="cov0" title="0">{
                return
        }</span>

        // Добавляем duration в атрибуты если есть
        <span class="cov8" title="27">if duration, ok := data["time"]; ok </span><span class="cov7" title="17">{
                if d, ok := duration.(time.Duration); ok </span><span class="cov6" title="15">{
                        data["duration_ms"] = d.Milliseconds()
                }</span>
                <span class="cov7" title="17">delete(data, "time")</span>
        }

        // Преобразуем в slog атрибуты
        <span class="cov8" title="27">attrs := make([]slog.Attr, 0, len(data))
        for k, v := range data </span><span class="cov10" title="59">{
                attrs = append(attrs, slog.Any(k, v))
        }</span>

        <span class="cov8" title="27">logger.FromContext(ctx).WithGroup("postgres").LogAttrs(ctx, l.slogLevel(level), msg, attrs...)</span>
}

func (l *Logger) slogLevel(level tracelog.LogLevel) slog.Level <span class="cov8" title="34">{
        switch level </span>{
        case tracelog.LogLevelTrace:<span class="cov2" title="2">
                return slog.LevelDebug - 1</span>
        case tracelog.LogLevelDebug:<span class="cov2" title="2">
                return slog.LevelDebug</span>
        case tracelog.LogLevelInfo:<span class="cov7" title="17">
                return slog.LevelInfo</span>
        case tracelog.LogLevelWarn:<span class="cov2" title="2">
                return slog.LevelWarn</span>
        case tracelog.LogLevelError:<span class="cov5" title="8">
                return slog.LevelError</span>
        default:<span class="cov3" title="3">
                return slog.LevelError</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package pgx

import (
        "context"
        "io"
        "time"

        "github.com/exaring/otelpgx"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/multitracer"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/tracelog"
        "github.com/pkg/errors"
)

// DB extends pgxpool.Pool functionality
type DB struct {
        *pgxpool.Pool
        io.Closer
}

type Options struct {
        Tracers []pgx.QueryTracer
}

func New(cfg Config, options *Options) (*DB, error) <span class="cov10" title="18">{
        dsn := cfg.URL().String()
        poolCfg, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.Wrap(err, "failed to pgxpool.ParseConfig")
        }</span>

        <span class="cov9" title="17">if cfg.MaxOpenConns &lt; 1 </span><span class="cov8" title="12">{
                cfg.MaxOpenConns = 1
        }</span>
        <span class="cov9" title="17">poolCfg.MaxConns = cfg.MaxOpenConns
        poolCfg.MaxConnLifetime = time.Duration(cfg.MaxConnLifeTime) * time.Second
        poolCfg.MaxConnIdleTime = time.Duration(cfg.MaxConnIdleTime) * time.Second
        poolCfg.HealthCheckPeriod = 20 * time.Second

        if options == nil </span><span class="cov4" title="3">{
                options = &amp;Options{}
        }</span>

        <span class="cov9" title="17">if len(options.Tracers) &gt; 0 </span><span class="cov9" title="14">{
                poolCfg.ConnConfig.Tracer = multitracer.New(options.Tracers...)
        }</span>

        <span class="cov9" title="17">pool, err := pgxpool.NewWithConfig(context.Background(), poolCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init database connections pool")
        }</span>
        <span class="cov9" title="17">if err := pool.Ping(context.Background()); err != nil </span><span class="cov9" title="17">{
                return nil, errors.Wrap(err, "failed to ping database")
        }</span>

        <span class="cov0" title="0">return &amp;DB{Pool: pool}, nil</span>
}

func NewDefault(c Config) (*DB, error) <span class="cov9" title="14">{
        return New(c, &amp;Options{
                Tracers: []pgx.QueryTracer{
                        otelpgx.NewTracer(),
                        &amp;tracelog.TraceLog{
                                Logger:   NewLogger(),
                                LogLevel: parseTraceLogLevel(c.TraceLogLevel),
                        },
                },
        })
}</span>

func (db *DB) Close() error <span class="cov0" title="0">{
        db.Pool.Close()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package pgx

import (
        "github.com/jackc/pgx/v5/tracelog"
)

func parseTraceLogLevel(lvl string) tracelog.LogLevel <span class="cov10" title="53">{
        logLevel, err := tracelog.LogLevelFromString(lvl)
        if err != nil </span><span class="cov8" title="27">{
                logLevel = tracelog.LogLevelNone
        }</span>

        <span class="cov10" title="53">return logLevel</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package sqlx

import (
        "context"
        "fmt"

        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq" // Стандартный драйвер PostgreSQL
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel/attribute"
)

// Connection представляет соединение с базой данных PostgreSQL через sqlx
type Connection struct {
        *sqlx.DB
        cfg Config
}

// Connect создает новое соединение с базой данных PostgreSQL
func Connect(ctx context.Context, cfg Config) (*Connection, error) <span class="cov10" title="4">{
        ctx, span := tracer.Start(ctx, "sqlx.Connect")
        defer span.End()

        span.SetAttributes(
                attribute.String("db.system", "postgresql"),
                attribute.String("db.host", cfg.Host),
                attribute.Int("db.port", cfg.Port),
                attribute.String("db.name", cfg.Database),
                attribute.String("db.user", cfg.User),
        )

        dsn := fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Database, cfg.SSLMode,
        )

        if cfg.ConnectTimeout &gt; 0 </span><span class="cov10" title="4">{
                dsn += fmt.Sprintf(" connect_timeout=%d", cfg.ConnectTimeout)
        }</span>

        <span class="cov10" title="4">dsn += " application_name=sqlx"

        db, err := sqlx.ConnectContext(ctx, "postgres", dsn)
        if err != nil </span><span class="cov5" title="2">{
                span.RecordError(err)
                return nil, errors.Wrap(err, "failed to connect to PostgreSQL")
        }</span>

        <span class="cov5" title="2">if cfg.MaxOpenConns &gt; 0 </span><span class="cov0" title="0">{
                db.SetMaxOpenConns(cfg.MaxOpenConns)
                span.SetAttributes(attribute.Int("db.max_open_conns", cfg.MaxOpenConns))
        }</span>

        <span class="cov5" title="2">if cfg.MaxIdleConns &gt; 0 </span><span class="cov0" title="0">{
                db.SetMaxIdleConns(cfg.MaxIdleConns)
                span.SetAttributes(attribute.Int("db.max_idle_conns", cfg.MaxIdleConns))
        }</span>

        <span class="cov5" title="2">if cfg.ConnMaxLifetime &gt; 0 </span><span class="cov0" title="0">{
                db.SetConnMaxLifetime(cfg.ConnMaxLifetime)
                span.SetAttributes(attribute.String("db.conn_max_lifetime", cfg.ConnMaxLifetime.String()))
        }</span>

        <span class="cov5" title="2">if cfg.ConnMaxIdleTime &gt; 0 </span><span class="cov0" title="0">{
                db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)
                span.SetAttributes(attribute.String("db.conn_max_idle_time", cfg.ConnMaxIdleTime.String()))
        }</span>

        // Проверка соединения
        <span class="cov5" title="2">if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                return nil, errors.Wrap(err, "failed to ping PostgreSQL")
        }</span>

        <span class="cov5" title="2">return &amp;Connection{
                DB:  db,
                cfg: cfg,
        }, nil</span>
}

// Close закрывает соединение с базой данных
func (c *Connection) Close() error <span class="cov1" title="1">{
        _, span := tracer.Start(context.Background(), "sqlx.Close")
        defer span.End()

        if err := c.DB.Close(); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                return errors.Wrap(err, "failed to close database connection")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package sqlx

import (
        "errors"
        "strings"

        "github.com/lib/pq"
)

// Коды ошибок PostgreSQL
const (
        UniqueViolationCode     = pq.ErrorCode("23505")
        ForeignKeyViolationCode = pq.ErrorCode("23503")
        CheckViolationCode      = pq.ErrorCode("23514")
        NotNullViolationCode    = pq.ErrorCode("23502")
)

// IsUniqueViolation проверяет, является ли ошибка нарушением ограничения уникальности
func IsUniqueViolation(err error) bool <span class="cov10" title="4">{
        var pqErr *pq.Error
        return errors.As(err, &amp;pqErr) &amp;&amp; pqErr.Code == UniqueViolationCode
}</span>

// IsForeignKeyViolation проверяет, является ли ошибка нарушением внешнего ключа
func IsForeignKeyViolation(err error) bool <span class="cov5" title="2">{
        var pqErr *pq.Error
        return errors.As(err, &amp;pqErr) &amp;&amp; pqErr.Code == ForeignKeyViolationCode
}</span>

// IsCheckViolation проверяет, является ли ошибка нарушением ограничения CHECK
func IsCheckViolation(err error) bool <span class="cov8" title="3">{
        var pqErr *pq.Error
        return errors.As(err, &amp;pqErr) &amp;&amp; pqErr.Code == CheckViolationCode
}</span>

// IsNotNullViolation проверяет, является ли ошибка нарушением ограничения NOT NULL
func IsNotNullViolation(err error) bool <span class="cov5" title="2">{
        var pqErr *pq.Error
        return errors.As(err, &amp;pqErr) &amp;&amp; pqErr.Code == NotNullViolationCode
}</span>

// IsConstraintViolation проверяет, является ли ошибка нарушением любого ограничения
func IsConstraintViolation(err error) bool <span class="cov8" title="3">{
        var pqErr *pq.Error
        if !errors.As(err, &amp;pqErr) </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov5" title="2">return pqErr.Code == UniqueViolationCode ||
                pqErr.Code == ForeignKeyViolationCode ||
                pqErr.Code == CheckViolationCode ||
                pqErr.Code == NotNullViolationCode</span>
}

// GetConstraintName извлекает имя нарушенного ограничения из ошибки
func GetConstraintName(err error) string <span class="cov5" title="2">{
        var pqErr *pq.Error
        if !errors.As(err, &amp;pqErr) </span><span class="cov1" title="1">{
                return ""
        }</span>

        // Формат сообщения: ошибка нарушения ограничения уникальности "constraint_name"
        <span class="cov1" title="1">parts := strings.Split(pqErr.Message, "\"")
        if len(parts) &gt;= 3 </span><span class="cov1" title="1">{
                return parts[1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package sqlx

import (
        "context"
        "database/sql"
        "sync"
        "time"

        "github.com/jmoiron/sqlx"
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel/trace"
)

// Querier определяет интерфейс для выполнения запросов к базе данных
type Querier interface {
        Get(ctx context.Context, dst interface{}, query string, args ...interface{}) error
        Select(ctx context.Context, dst interface{}, query string, args ...interface{}) error
        Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
        Query(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error)
        QueryRow(ctx context.Context, query string, args ...interface{}) *sqlx.Row
        NamedExec(ctx context.Context, query string, arg interface{}) (sql.Result, error)
        NamedQuery(ctx context.Context, query string, arg interface{}) (*sqlx.Rows, error)
}

// Get выполняет запрос и заполняет одну запись
func (c *Connection) Get(ctx context.Context, dst interface{}, query string, args ...interface{}) error <span class="cov4" title="11">{
        ctx, cancel := WithTimeout(ctx, c.cfg.QueryTimeout)
        defer cancel()

        ctx, span := c.WithTracing(ctx, "Get", query)
        defer span.End()

        err := c.DB.GetContext(ctx, dst, query, args...)
        if err != nil </span><span class="cov2" title="2">{
                span.RecordError(err)
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov1" title="1">return errors.Wrap(err, "failed to execute get query")</span>
        }
        <span class="cov4" title="9">return nil</span>
}

// Select выполняет запрос и заполняет срез записей
func (c *Connection) Select(ctx context.Context, dst interface{}, query string, args ...interface{}) error <span class="cov2" title="2">{
        ctx, cancel := WithTimeout(ctx, c.cfg.QueryTimeout)
        defer cancel()

        ctx, span := c.WithTracing(ctx, "Select", query)
        defer span.End()

        err := c.DB.SelectContext(ctx, dst, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                return errors.Wrap(err, "failed to execute select query")
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// Exec выполняет запрос и возвращает результат
func (c *Connection) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov6" title="42">{
        ctx, cancel := WithTimeout(ctx, c.cfg.QueryTimeout)
        defer cancel()

        ctx, span := c.WithTracing(ctx, "Exec", query)
        defer span.End()

        result, err := c.DB.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov4" title="9">{
                span.RecordError(err)
                return nil, errors.Wrap(err, "failed to execute query")
        }</span>
        <span class="cov6" title="33">return result, nil</span>
}

// Query выполняет запрос и возвращает строки результата
func (c *Connection) Query(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) <span class="cov2" title="3">{
        ctx, cancel := WithTimeout(ctx, c.cfg.QueryTimeout)
        defer cancel()

        ctx, span := c.WithTracing(ctx, "Query", query)
        defer span.End()

        rows, err := c.DB.QueryxContext(ctx, query, args...)
        if err != nil </span><span class="cov2" title="2">{
                span.RecordError(err)
                return nil, errors.Wrap(err, "failed to execute query")
        }</span>
        <span class="cov1" title="1">return rows, nil</span>
}

// QueryRow выполняет запрос и возвращает одну строку результата
func (c *Connection) QueryRow(ctx context.Context, query string, args ...interface{}) *sqlx.Row <span class="cov2" title="3">{
        ctx, span := c.WithTracing(ctx, "QueryRow", query)
        defer span.End()

        // Note: We don't apply QueryTimeout here because sqlx.Row is lazy-evaluated.
        // The query is executed when Scan() is called, so canceling the context here
        // would cause "context canceled" errors. The caller should manage context lifetime.
        return c.DB.QueryRowxContext(ctx, query, args...)
}</span>

// NamedExec выполняет именованный запрос
func (c *Connection) NamedExec(ctx context.Context, query string, arg interface{}) (sql.Result, error) <span class="cov1" title="1">{
        ctx, cancel := WithTimeout(ctx, c.cfg.QueryTimeout)
        defer cancel()

        ctx, span := c.WithTracing(ctx, "NamedExec", query)
        defer span.End()

        result, err := c.DB.NamedExecContext(ctx, query, arg)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                return nil, errors.Wrap(err, "failed to execute named query")
        }</span>
        <span class="cov1" title="1">return result, nil</span>
}

// NamedQuery выполняет именованный запрос и возвращает строки результата
func (c *Connection) NamedQuery(ctx context.Context, query string, arg interface{}) (*sqlx.Rows, error) <span class="cov2" title="2">{
        // Не отменяем контекст пока rows не будут закрыты
        // Вызывающий должен закрыть rows через defer rows.Close()
        ctx, cancel := WithTimeout(ctx, c.cfg.QueryTimeout)

        ctx, span := c.WithTracing(ctx, "NamedQuery", query)

        rows, err := c.DB.NamedQueryContext(ctx, query, arg)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                span.RecordError(err)
                span.End()
                return nil, errors.Wrap(err, "failed to execute named query")
        }</span>

        // Wrap rows to cancel context and end span when closed
        <span class="cov2" title="2">wrappedRows := &amp;namedQueryRows{
                Rows:   rows,
                cancel: cancel,
                span:   span,
                closed: false,
        }
        return wrappedRows.Rows, nil</span>
}

// namedQueryRows wraps sqlx.Rows to cleanup context and span
type namedQueryRows struct {
        *sqlx.Rows
        cancel context.CancelFunc
        span   trace.Span
        closed bool
        mu     sync.Mutex
}

func (r *namedQueryRows) Close() error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if r.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">r.closed = true
        r.cancel()
        r.span.End()
        return r.Rows.Close()</span>
}

// WithTimeout добавляет таймаут к контексту
func WithTimeout(ctx context.Context, timeout time.Duration) (context.Context, context.CancelFunc) <span class="cov10" title="280">{
        if timeout &gt; 0 </span><span class="cov9" title="279">{
                return context.WithTimeout(ctx, timeout)
        }</span>
        <span class="cov1" title="1">return context.WithCancel(ctx)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package sqlx

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

var tracer = otel.Tracer("github.com/pure-golang/adapters/db/pg/sqlx")

// TracingConfig содержит настройки для трейсинга
type TracingConfig struct {
        // CommentsAsAttributes добавляет SQL-комментарии как атрибуты спана
        CommentsAsAttributes bool
        // ExcludeErrors список ошибок, которые не нужно записывать в трейсинг
        ExcludeErrors []error
        // DisableErrSkip отключает пропуск ошибок из ExcludeErrors
        DisableErrSkip bool
}

// DefaultTracingConfig возвращает конфигурацию по умолчанию
func DefaultTracingConfig() *TracingConfig <span class="cov2" title="2">{
        return &amp;TracingConfig{
                CommentsAsAttributes: true,
                ExcludeErrors:        []error{pgx.ErrNoRows},
                DisableErrSkip:       false,
        }
}</span>

// WithTracing добавляет трейсинг к конфигурации подключения
func WithTracing(cfg *Config, _ *TracingConfig) *Config <span class="cov1" title="1">{
        return cfg
}</span>

// TracingQuerier определяет интерфейс для выполнения запросов с трейсингом
type TracingQuerier interface {
        Querier
        WithTracing(ctx context.Context, operation string, query string) (context.Context, trace.Span)
}

// WithTracing создает новый спан для операции с базой данных
func (c *Connection) WithTracing(ctx context.Context, operation string, query string) (context.Context, trace.Span) <span class="cov9" title="182">{
        ctx, span := tracer.Start(ctx, fmt.Sprintf("sqlx.%s", operation))
        span.SetAttributes(
                attribute.String("db.system", "postgresql"),
                attribute.String("db.operation", operation),
                attribute.String("db.statement", query),
        )
        return ctx, span
}</span>

// WithTracing создает новый спан для операции в транзакции
func (tx *Tx) WithTracing(ctx context.Context, operation string, query string) (context.Context, trace.Span) <span class="cov10" title="342">{
        ctx, span := tracer.Start(ctx, fmt.Sprintf("sqlx.tx.%s", operation))
        span.SetAttributes(
                attribute.String("db.system", "postgresql"),
                attribute.String("db.operation", operation),
                attribute.String("db.statement", query),
                attribute.Bool("db.transaction", true),
        )
        return ctx, span
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package sqlx

import (
        "context"
        "database/sql"

        "github.com/jmoiron/sqlx"
        "github.com/pkg/errors"
)

// Tx представляет транзакцию в базе данных
type Tx struct {
        tx  *sqlx.Tx
        cfg Config
}

// TxFunc определяет функцию, которая будет выполняться в рамках транзакции
type TxFunc func(ctx context.Context, tx *Tx) error

// TxOptions определяет опции транзакции
type TxOptions struct {
        Isolation  sql.IsolationLevel
        ReadOnly   bool
        Deferrable bool
}

// DefaultTxOptions возвращает опции транзакции по умолчанию
func DefaultTxOptions() *TxOptions <span class="cov2" title="2">{
        return &amp;TxOptions{
                Isolation: sql.LevelDefault,
                ReadOnly:  false,
        }
}</span>

// BeginTx начинает новую транзакцию с заданными опциями
func (c *Connection) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error) <span class="cov10" title="113">{
        var txOpts *sql.TxOptions
        if opts != nil </span><span class="cov2" title="2">{
                txOpts = &amp;sql.TxOptions{
                        Isolation: opts.Isolation,
                        ReadOnly:  opts.ReadOnly,
                }
        }</span>

        <span class="cov10" title="113">tx, err := c.DB.BeginTxx(ctx, txOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to begin transaction")
        }</span>

        <span class="cov10" title="113">return &amp;Tx{
                tx:  tx,
                cfg: c.cfg,
        }, nil</span>
}

// RunTx выполняет функцию в рамках транзакции
func (c *Connection) RunTx(ctx context.Context, opts *TxOptions, fn TxFunc) (err error) <span class="cov9" title="109">{
        tx, err := c.BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="109">ctx, span := c.WithTracing(ctx, "RunTx", "")
        defer span.End()

        // Автоматический Rollback при панике или ошибке
        defer func() </span><span class="cov9" title="109">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        rbErr := tx.Rollback()
                        span.RecordError(rbErr)
                        err = errors.Wrap(rbErr, "panic during transaction") // Сохраняем ошибку отката
                        panic(p)</span>                                             // Перебрасываем панику дальше
                } else<span class="cov9" title="109"> if err != nil </span><span class="cov1" title="1">{
                        rbErr := tx.Rollback()
                        if rbErr != nil </span><span class="cov0" title="0">{
                                span.RecordError(rbErr)
                                err = errors.Wrap(err, rbErr.Error()) // Объединяем ошибки
                        }</span>
                }
        }()

        <span class="cov9" title="109">if err = fn(ctx, tx); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                return err // Rollback будет выполнен в defer
        }</span>

        <span class="cov9" title="108">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                return errors.Wrap(err, "failed to commit transaction")
        }</span>

        <span class="cov9" title="108">return nil</span>
}

// Commit фиксирует транзакцию
func (tx *Tx) Commit() error <span class="cov9" title="111">{
        _, span := tx.WithTracing(context.Background(), "Commit", "")
        defer span.End()

        if err := tx.tx.Commit(); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                return errors.Wrap(err, "failed to commit transaction")
        }</span>
        <span class="cov9" title="110">return nil</span>
}

// Rollback откатывает транзакцию
func (tx *Tx) Rollback() error <span class="cov3" title="4">{
        _, span := tx.WithTracing(context.Background(), "Rollback", "")
        defer span.End()

        if err := tx.tx.Rollback(); err != nil &amp;&amp; err != sql.ErrTxDone </span><span class="cov0" title="0">{
                span.RecordError(err)
                return errors.Wrap(err, "failed to rollback transaction")
        }</span>
        <span class="cov3" title="4">return nil</span>
}

// Get выполняет запрос в транзакции и заполняет одну запись
func (tx *Tx) Get(ctx context.Context, dst interface{}, query string, args ...interface{}) error <span class="cov9" title="106">{
        ctx, cancel := WithTimeout(ctx, tx.cfg.QueryTimeout)
        defer cancel()

        ctx, span := tx.WithTracing(ctx, "Get", query)
        defer span.End()

        err := tx.tx.GetContext(ctx, dst, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, "failed to execute get query in transaction")</span>
        }
        <span class="cov9" title="106">return nil</span>
}

// Select выполняет запрос в транзакции и заполняет срез записей
func (tx *Tx) Select(ctx context.Context, dst interface{}, query string, args ...interface{}) error <span class="cov1" title="1">{
        ctx, cancel := WithTimeout(ctx, tx.cfg.QueryTimeout)
        defer cancel()

        ctx, span := tx.WithTracing(ctx, "Select", query)
        defer span.End()

        err := tx.tx.SelectContext(ctx, dst, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                return errors.Wrap(err, "failed to execute select query in transaction")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Exec выполняет запрос в транзакции и возвращает результат
func (tx *Tx) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov9" title="110">{
        ctx, cancel := WithTimeout(ctx, tx.cfg.QueryTimeout)
        defer cancel()

        ctx, span := tx.WithTracing(ctx, "Exec", query)
        defer span.End()

        result, err := tx.tx.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                return nil, errors.Wrap(err, "failed to execute query in transaction")
        }</span>
        <span class="cov9" title="109">return result, nil</span>
}

// Query выполняет запрос в транзакции и возвращает строки результата
func (tx *Tx) Query(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) <span class="cov0" title="0">{
        ctx, cancel := WithTimeout(ctx, tx.cfg.QueryTimeout)
        defer cancel()

        ctx, span := tx.WithTracing(ctx, "Query", query)
        defer span.End()

        rows, err := tx.tx.QueryxContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                return nil, errors.Wrap(err, "failed to execute query in transaction")
        }</span>
        <span class="cov0" title="0">return rows, nil</span>
}

// QueryRow выполняет запрос в транзакции и возвращает одну строку результата
// Note: This method returns a lazy *sqlx.Row. The query is executed when Scan() is called.
// The context timeout is applied per the original context, as we cannot defer cleanup
// before Scan() is called by the caller.
func (tx *Tx) QueryRow(ctx context.Context, query string, args ...interface{}) *sqlx.Row <span class="cov1" title="1">{
        ctx, span := tx.WithTracing(ctx, "QueryRow", query)
        // End the span after the row is created (the actual query happens during Scan)
        // This is a limitation of the lazy evaluation pattern in sqlx.Row
        defer span.End()

        // Note: We don't apply QueryTimeout here because sqlx.Row is lazy-evaluated.
        // The query is executed when Scan() is called, so canceling the context here
        // would cause "context canceled" errors. The caller should manage context lifetime.
        return tx.tx.QueryRowxContext(ctx, query, args...)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package env

import (
        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
        "github.com/pkg/errors"
)

const DefaultEnvFile = ".env"

func InitConfig(config any) error <span class="cov10" title="24">{
        // Try to load .env file, but don't fail if it doesn't exist
        // nolint:errcheck // .env file is optional, failure is acceptable
        _ = godotenv.Load(DefaultEnvFile)

        if err := envconfig.Process("", config); err != nil </span><span class="cov5" title="5">{
                return errors.Wrap(err, "failed to envconfig.Process")
        }</span>

        <span class="cov9" title="19">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cli

import (
        "context"
        "io"
        "log/slog"
        "os"
        "os/exec"
        "sync"
        "time"

        "github.com/pkg/errors"
        "go.opentelemetry.io/otel/codes"

        "github.com/pure-golang/adapters/executor"
)

var _ executor.Executor = (*Executor)(nil)

// Executor реализует интерфейс executor.Executor для CLI утилит
type Executor struct {
        logger *slog.Logger
        cmd    string
        stdout io.Writer
        stderr io.Writer
        closed bool
        mx     sync.Mutex
}

// New создаёт новый CLI executor
func New(cfg Config, stdout, stderr io.Writer) *Executor <span class="cov0" title="0">{
        var tmpStdout io.Writer
        if stdout == nil </span><span class="cov0" title="0">{
                tmpStdout = os.Stdout
        }</span> else<span class="cov0" title="0"> {
                tmpStdout = stdout
        }</span>
        <span class="cov0" title="0">var tmpStderr io.Writer
        if stderr == nil </span><span class="cov0" title="0">{
                tmpStderr = os.Stderr
        }</span> else<span class="cov0" title="0"> {
                tmpStderr = stderr
        }</span>
        <span class="cov0" title="0">return &amp;Executor{
                logger: slog.Default().With("executor/cli", cfg.Command),
                cmd:    cfg.Command,
                stdout: tmpStdout,
                stderr: tmpStderr,
                closed: false,
        }</span>
}

// Start проверяет наличие команды в системе
func (e *Executor) Start() error <span class="cov0" title="0">{
        e.logger.Info("checking command availability", "command", e.cmd)

        if _, err := exec.LookPath(e.cmd); err != nil </span><span class="cov0" title="0">{
                e.logger.Error("command not found", "command", e.cmd, "error", err)
                return errors.Wrapf(err, "command %q not found", e.cmd)
        }</span>

        <span class="cov0" title="0">e.logger.Info("command found", "command", e.cmd)
        return nil</span>
}

// Execute выполняет команду с заданным контекстом и аргументами
func (e *Executor) Execute(ctx context.Context, args ...string) error <span class="cov0" title="0">{
        // 1. КРИТИЧЕСКАЯ СЕКЦИЯ (только проверка и регистрация)
        e.mx.Lock()
        if e.closed </span><span class="cov0" title="0">{
                e.mx.Unlock()
                e.logger.Error("attempting to execute command on closed executor", "command", e.cmd)
                return errors.New("executor is closed")
        }</span>
        // Создание команды
        //nolint:gosec // G204: Subprocess launched with a potential tainted input or cmd arguments - e.cmd is validated in Start(), args are user-controlled but not shell-expanded
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, e.cmd, args...)
        cmd.Stdout = e.stdout
        cmd.Stderr = e.stderr
        e.mx.Unlock()

        // 2. ВЫПОЛНЕНИЕ (параллельно, без блокировки мьютекса)
        e.logger.Info("executing command", "command", e.cmd, "args", args)

        _, span := tracer.Start(ctx, "executor.Execute")
        defer span.End()

        startTime := time.Now()
        err := cmd.Run()
        duration := time.Since(startTime).Seconds()

        if err != nil </span><span class="cov0" title="0">{
                e.logger.Error("command execution error", "command", e.cmd, "args", args, "error", err, "duration_seconds", duration)
                recordError(span, err)
                recordExecution(e.cmd, "error", duration)
                return errors.Wrapf(err, "command failed: %q", e.cmd)
        }</span>

        <span class="cov0" title="0">e.logger.Info("command executed successfully", "command", e.cmd, "args", args, "duration_seconds", duration)
        span.SetStatus(codes.Ok, "")
        recordExecution(e.cmd, "success", duration)
        return nil</span>
}

// Close закрывает executor
func (e *Executor) Close() error <span class="cov0" title="0">{
        e.mx.Lock()
        if e.closed </span><span class="cov0" title="0">{
                e.mx.Unlock()
                return errors.New("executor is already closed")
        }</span>
        <span class="cov0" title="0">e.closed = true
        e.mx.Unlock()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cli

import (
        "github.com/kelseyhightower/envconfig"
)

// Config содержит конфигурацию CLI executor
type Config struct {
        // Command - имя исполняемой команды (например, "ffmpeg", "gsutil", "aws")
        // Загружается из переменной окружения CLI_COMMAND
        Command string `envconfig:"CLI_COMMAND" required:"true"`
}

// InitConfig загружает конфигурацию из переменных окружения
func InitConfig(cfg *Config) error <span class="cov0" title="0">{
        return envconfig.Process("", cfg)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package cli

import (
        "github.com/prometheus/client_golang/prometheus"
)

var (
        // execDuration - гистограмма длительности выполнения команд
        execDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "executor_cli_duration_seconds",
                        Help:    "Длительность выполнения CLI команд",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"command", "status"},
        )

        // execTotal - счётчик выполненных команд
        execTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "executor_cli_executions_total",
                        Help: "Общее количество выполнений CLI команд",
                },
                []string{"command", "status"},
        )
)

func init() <span class="cov8" title="1">{
        // Регистрация метрик в Prometheus
        prometheus.MustRegister(execDuration)
        prometheus.MustRegister(execTotal)
}</span>

// recordExecution записывает метрики выполнения команды
func recordExecution(command string, status string, duration float64) <span class="cov0" title="0">{
        execDuration.WithLabelValues(command, status).Observe(duration)
        execTotal.WithLabelValues(command, status).Inc()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package cli

import (
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

var tracer = otel.Tracer("github.com/pure-golang/adapters/executor/cli")

// recordError записывает ошибку в span
func recordError(span trace.Span, err error) <span class="cov0" title="0">{
        if span == nil || err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package errors

import (
        "context"

        "github.com/pkg/errors"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// FromError преобразует ошибки в gRPC-статусы
func FromError(err error) error <span class="cov7" title="9">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov6" title="8">switch </span>{
        case errors.Is(err, context.Canceled):<span class="cov2" title="2">
                return status.Error(codes.Canceled, "request canceled")</span>
        case errors.Is(err, context.DeadlineExceeded):<span class="cov2" title="2">
                return status.Error(codes.DeadlineExceeded, "deadline exceeded")</span>
        }

        // Если ошибка уже является gRPC-статусом, возвращаем её как есть
        <span class="cov4" title="4">if _, ok := status.FromError(err); ok </span><span class="cov4" title="3">{
                return err
        }</span>

        // По умолчанию используем Internal с исходным сообщением
        <span class="cov1" title="1">return status.Error(codes.Internal, err.Error())</span>
}

// WrapError оборачивает ошибку с заданным кодом статуса и сообщением
func WrapError(err error, code codes.Code, msg string) error <span class="cov9" title="23">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="22">return status.Errorf(code, "%s: %v", msg, err)</span>
}

// NewError создает новую ошибку с заданным кодом и сообщением
func NewError(code codes.Code, msg string) error <span class="cov10" title="24">{
        return status.Error(code, msg)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/status"
)

// LoggingInterceptor создает интерцептор для логирования gRPC запросов
func LoggingInterceptor(logger *slog.Logger) grpc.UnaryServerInterceptor <span class="cov10" title="60">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov6" title="12">{
                start := time.Now()
                resp, err := handler(ctx, req)
                duration := time.Since(start)

                logAttrs := []any{
                        slog.String("method", info.FullMethod),
                        slog.Duration("duration", duration),
                }

                // Добавляем информацию о статусе
                if err != nil </span><span class="cov5" title="7">{
                        s := status.Convert(err)
                        logAttrs = append(logAttrs,
                                slog.String("status_code", s.Code().String()),
                                slog.Any("error", err),
                        )
                        logger.ErrorContext(ctx, "gRPC request failed", logAttrs...)
                }</span> else<span class="cov4" title="5"> {
                        logAttrs = append(logAttrs, slog.String("status_code", "OK"))
                        logger.InfoContext(ctx, "gRPC request processed", logAttrs...)
                }</span>

                <span class="cov6" title="12">return resp, err</span>
        }
}

// RecoveryInterceptor создает интерцептор для восстановления после паники
func RecoveryInterceptor(logger *slog.Logger) grpc.UnaryServerInterceptor <span class="cov9" title="51">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) </span><span class="cov5" title="7">{
                defer func() </span><span class="cov5" title="7">{
                        if r := recover(); r != nil </span><span class="cov4" title="5">{
                                logger.ErrorContext(ctx, "Recovered from panic in gRPC handler",
                                        slog.Any("panic", r),
                                        slog.String("method", info.FullMethod),
                                )
                                err = status.Error(14, "internal server error") // UNAVAILABLE
                        }</span>
                }()
                <span class="cov5" title="7">return handler(ctx, req)</span>
        }
}

// LoggingStreamInterceptor создает интерцептор для логирования потоковых gRPC запросов
func LoggingStreamInterceptor(logger *slog.Logger) grpc.StreamServerInterceptor <span class="cov9" title="53">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov4" title="6">{
                start := time.Now()
                err := handler(srv, ss)
                duration := time.Since(start)

                logAttrs := []any{
                        slog.String("method", info.FullMethod),
                        slog.Duration("duration", duration),
                        slog.Bool("client_stream", info.IsClientStream),
                        slog.Bool("server_stream", info.IsServerStream),
                }

                if err != nil </span><span class="cov1" title="1">{
                        s := status.Convert(err)
                        logAttrs = append(logAttrs,
                                slog.String("status_code", s.Code().String()),
                                slog.Any("error", err),
                        )
                        logger.ErrorContext(ss.Context(), "gRPC stream failed", logAttrs...)
                }</span> else<span class="cov4" title="5"> {
                        logAttrs = append(logAttrs, slog.String("status_code", "OK"))
                        logger.InfoContext(ss.Context(), "gRPC stream processed", logAttrs...)
                }</span>

                <span class="cov4" title="6">return err</span>
        }
}

// RecoveryStreamInterceptor создает интерцептор для восстановления в потоковых запросах
func RecoveryStreamInterceptor(logger *slog.Logger) grpc.StreamServerInterceptor <span class="cov9" title="50">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) (err error) </span><span class="cov3" title="3">{
                defer func() </span><span class="cov3" title="3">{
                        if r := recover(); r != nil </span><span class="cov2" title="2">{
                                logger.ErrorContext(ss.Context(), "Recovered from panic in gRPC stream handler",
                                        slog.Any("panic", r),
                                        slog.String("method", info.FullMethod),
                                )
                                err = status.Error(14, "internal server error") // UNAVAILABLE
                        }</span>
                }()
                <span class="cov3" title="3">return handler(srv, ss)</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "context"
        "time"

        "github.com/pkg/errors"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/metric"
        "google.golang.org/grpc"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

var (
        meter = otel.Meter("github.com/pure-golang/adapters/grpc")

        requestsCount       metric.Int64Counter
        requestDuration     metric.Int64Histogram
        requestPayloadSize  metric.Int64Histogram
        responsePayloadSize metric.Int64Histogram
)

func init() <span class="cov2" title="2">{
        var err error

        requestsCount, err = meter.Int64Counter(
                "grpc.server.requests_total",
                metric.WithDescription("Total number of gRPC requests"),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrap(err, "failed to create requests counter"))</span>
        }

        <span class="cov2" title="2">requestDuration, err = meter.Int64Histogram(
                "grpc.server.duration_ms",
                metric.WithDescription("gRPC request duration in milliseconds"),
                metric.WithUnit("ms"),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrap(err, "failed to create request duration histogram"))</span>
        }

        <span class="cov2" title="2">requestPayloadSize, err = meter.Int64Histogram(
                "grpc.server.request_size_bytes",
                metric.WithDescription("gRPC request size in bytes"),
                metric.WithUnit("bytes"),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrap(err, "failed to create request size histogram"))</span>
        }

        <span class="cov2" title="2">responsePayloadSize, err = meter.Int64Histogram(
                "grpc.server.response_size_bytes",
                metric.WithDescription("gRPC response size in bytes"),
                metric.WithUnit("bytes"),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrap(err, "failed to create response size histogram"))</span>
        }
}

// getMessageSize возвращает размер protobuf сообщения в байтах
func getMessageSize(msg interface{}) int64 <span class="cov10" title="71">{
        if pm, ok := msg.(proto.Message); ok </span><span class="cov8" title="37">{
                return int64(proto.Size(pm))
        }</span>
        <span class="cov8" title="34">return 0</span>
}

// MetricsUnaryInterceptor создает интерцептор для метрик gRPC запросов
func MetricsUnaryInterceptor() grpc.UnaryServerInterceptor <span class="cov9" title="59">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="29">{
                startTime := time.Now()

                // Измеряем размер запроса
                requestSize := getMessageSize(req)
                requestPayloadSize.Record(ctx, requestSize, metric.WithAttributes(
                        attribute.String("grpc.method", info.FullMethod),
                ))

                // Атрибуты для метрик
                metricAttrs := []attribute.KeyValue{
                        attribute.String("grpc.method", info.FullMethod),
                }

                // Обрабатываем запрос
                resp, err := handler(ctx, req)

                // Измеряем размер ответа
                responseSize := getMessageSize(resp)
                responsePayloadSize.Record(ctx, responseSize, metric.WithAttributes(
                        attribute.String("grpc.method", info.FullMethod),
                ))

                // Записываем метрики
                duration := time.Since(startTime)
                requestDuration.Record(ctx, duration.Milliseconds(), metric.WithAttributes(metricAttrs...))

                // Добавляем код статуса
                statusCode := status.Code(err)
                statusAttrs := append(metricAttrs, attribute.String("grpc.status", statusCode.String()))
                requestsCount.Add(ctx, 1, metric.WithAttributes(statusAttrs...))

                return resp, err
        }</span>
}

// MetricsStreamInterceptor создает интерцептор для метрик потоковых gRPC запросов
func MetricsStreamInterceptor() grpc.StreamServerInterceptor <span class="cov9" title="55">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov6" title="13">{
                startTime := time.Now()

                // Определяем тип потока
                streamType := "server_streaming"
                if info.IsClientStream </span><span class="cov2" title="2">{
                        streamType = "client_streaming"
                }</span>
                <span class="cov6" title="13">if info.IsClientStream &amp;&amp; info.IsServerStream </span><span class="cov1" title="1">{
                        streamType = "bidi_streaming"
                }</span>

                <span class="cov6" title="13">metricAttrs := []attribute.KeyValue{
                        attribute.String("grpc.method", info.FullMethod),
                        attribute.String("stream.type", streamType),
                }

                // Обрабатываем поток
                err := handler(srv, ss)

                // Записываем метрики
                duration := time.Since(startTime)
                requestDuration.Record(ss.Context(), duration.Milliseconds(), metric.WithAttributes(metricAttrs...))

                // Добавляем код статуса
                statusCode := status.Code(err)
                statusAttrs := append(metricAttrs, attribute.String("grpc.status", statusCode.String()))
                requestsCount.Add(ss.Context(), 1, metric.WithAttributes(statusAttrs...))

                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "context"
        "log/slog"

        "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
        "go.opentelemetry.io/otel"
        "google.golang.org/grpc"
)

// MonitoringOptions содержит настройки мониторинга
type MonitoringOptions struct {
        Logger             *slog.Logger
        EnableTracing      bool
        EnableMetrics      bool
        EnableLogging      bool
        EnableStatsHandler bool
}

// DefaultMonitoringOptions возвращает настройки по умолчанию
func DefaultMonitoringOptions(logger *slog.Logger) *MonitoringOptions <span class="cov9" title="42">{
        return &amp;MonitoringOptions{
                Logger:             logger,
                EnableTracing:      true,
                EnableMetrics:      true,
                EnableLogging:      true,
                EnableStatsHandler: true,
        }
}</span>

// SetupMonitoring настраивает все компоненты мониторинга для gRPC сервера
// и возвращает необходимые интерцепторы и опции сервера
func SetupMonitoring(
        ctx context.Context,
        options *MonitoringOptions,
) ([]grpc.UnaryServerInterceptor, []grpc.StreamServerInterceptor, []grpc.ServerOption) <span class="cov10" title="57">{

        unaryInterceptors := []grpc.UnaryServerInterceptor{}
        streamInterceptors := []grpc.StreamServerInterceptor{}
        serverOptions := []grpc.ServerOption{}

        // Настраиваем трассировку OpenTelemetry
        if options.EnableTracing </span><span class="cov9" title="49">{
                // Устанавливаем пропагатор контекста для трассировки
                otel.SetTextMapPropagator(MetadataTextMapPropagator())

                // Добавляем интерцепторы трассировки
                unaryInterceptors = append(unaryInterceptors, TracingUnaryInterceptor())
                streamInterceptors = append(streamInterceptors, TracingStreamInterceptor())

                // Добавляем StatsHandler для дополнительных метрик трассировки
                if options.EnableStatsHandler </span><span class="cov9" title="46">{
                        serverOptions = append(serverOptions, grpc.StatsHandler(otelgrpc.NewServerHandler()))
                }</span>
        }

        // Добавляем метрики Prometheus
        <span class="cov10" title="57">if options.EnableMetrics </span><span class="cov9" title="48">{
                unaryInterceptors = append(unaryInterceptors, MetricsUnaryInterceptor())
                streamInterceptors = append(streamInterceptors, MetricsStreamInterceptor())
        }</span>

        // Добавляем логирование и восстановление после паники
        <span class="cov10" title="57">if options.EnableLogging </span><span class="cov9" title="49">{
                unaryInterceptors = append(unaryInterceptors,
                        RecoveryInterceptor(options.Logger),
                        LoggingInterceptor(options.Logger),
                )
                streamInterceptors = append(streamInterceptors,
                        RecoveryStreamInterceptor(options.Logger),
                        LoggingStreamInterceptor(options.Logger),
                )
        }</span>

        <span class="cov10" title="57">return unaryInterceptors, streamInterceptors, serverOptions</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "context"
        "path"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

var tracer = otel.Tracer("github.com/pure-golang/adapters/grpc")

// metadataSupplier реализует propagation.TextMapCarrier для gRPC метаданных
type metadataSupplier struct {
        metadata *metadata.MD
}

func (s metadataSupplier) Get(key string) string <span class="cov9" title="61">{
        values := s.metadata.Get(key)
        if len(values) == 0 </span><span class="cov9" title="56">{
                return ""
        }</span>
        <span class="cov4" title="5">return values[0]</span>
}

func (s metadataSupplier) Set(key string, value string) <span class="cov4" title="6">{
        s.metadata.Set(key, value)
}</span>

func (s metadataSupplier) Keys() []string <span class="cov3" title="3">{
        keys := make([]string, 0, 10)
        for key := range *s.metadata </span><span class="cov4" title="4">{
                keys = append(keys, key)
        }</span>
        <span class="cov3" title="3">return keys</span>
}

// TracingUnaryInterceptor создает интерцептор для трассировки унарных RPC
func TracingUnaryInterceptor() grpc.UnaryServerInterceptor <span class="cov9" title="55">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov7" title="19">{
                // Извлекаем метаданные
                md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov7" title="18">{
                        md = metadata.New(nil)
                }</span>

                // Получаем сервис и метод из полного пути
                <span class="cov7" title="19">service, method := splitMethodName(info.FullMethod)

                // Создаем контекст с пропагацией трассировки
                var span trace.Span
                ctx = otel.GetTextMapPropagator().Extract(ctx, metadataSupplier{metadata: &amp;md})

                // Начинаем новый спан
                ctx, span = tracer.Start(
                        ctx,
                        path.Join(service, method),
                        trace.WithSpanKind(trace.SpanKindServer),
                        trace.WithAttributes(
                                attribute.String("rpc.system", "grpc"),
                                attribute.String("rpc.service", service),
                                attribute.String("rpc.method", method),
                        ),
                )
                defer span.End()

                startTime := time.Now()

                // Записываем запрос в спан как событие
                span.AddEvent("request_received", trace.WithAttributes(
                        attribute.String("request.type", "unary"),
                ))

                // Вызываем обработчик с контекстом, содержащим спан
                resp, err := handler(ctx, req)

                // Записываем длительность
                duration := time.Since(startTime)
                span.SetAttributes(attribute.Int64("request.duration_ms", duration.Milliseconds()))

                // Обработка ошибок
                if err != nil </span><span class="cov6" title="14">{
                        s, _ := status.FromError(err)
                        span.SetStatus(codes.Error, s.Message())
                        span.SetAttributes(
                                attribute.String("rpc.status_code", s.Code().String()),
                                attribute.String("error.message", err.Error()),
                        )
                        span.RecordError(err)
                }</span> else<span class="cov4" title="5"> {
                        span.SetStatus(codes.Ok, "")
                        span.SetAttributes(attribute.String("rpc.status_code", "OK"))
                }</span>

                // Записываем ответ как событие
                <span class="cov7" title="19">span.AddEvent("response_sent", trace.WithAttributes(
                        attribute.Bool("response.error", err != nil),
                ))

                return resp, err</span>
        }
}

// TracingStreamInterceptor создает интерцептор для трассировки потоковых RPC
func TracingStreamInterceptor() grpc.StreamServerInterceptor <span class="cov9" title="54">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov5" title="7">{
                // Извлекаем метаданные
                ctx := ss.Context()
                md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov4" title="6">{
                        md = metadata.New(nil)
                }</span>

                // Получаем сервис и метод из полного пути
                <span class="cov5" title="7">service, method := splitMethodName(info.FullMethod)

                // Создаем контекст с пропагацией трассировки
                var span trace.Span
                ctx = otel.GetTextMapPropagator().Extract(ctx, metadataSupplier{metadata: &amp;md})

                // Начинаем новый спан
                streamType := "server_streaming"
                if info.IsClientStream </span><span class="cov3" title="3">{
                        streamType = "client_streaming"
                }</span>
                <span class="cov5" title="7">if info.IsClientStream &amp;&amp; info.IsServerStream </span><span class="cov2" title="2">{
                        streamType = "bidi_streaming"
                }</span>

                <span class="cov5" title="7">ctx, span = tracer.Start(
                        ctx,
                        path.Join(service, method),
                        trace.WithSpanKind(trace.SpanKindServer),
                        trace.WithAttributes(
                                attribute.String("rpc.system", "grpc"),
                                attribute.String("rpc.service", service),
                                attribute.String("rpc.method", method),
                                attribute.String("stream.type", streamType),
                        ),
                )
                defer span.End()

                startTime := time.Now()

                // Оборачиваем ServerStream, чтобы использовать контекст с трассировкой
                wrappedStream := &amp;wrappedServerStream{
                        ServerStream: ss,
                        ctx:          ctx,
                }

                // Записываем начало обработки потока
                span.AddEvent("stream_started")

                // Обрабатываем поток
                err := handler(srv, wrappedStream)

                // Записываем длительность
                duration := time.Since(startTime)
                span.SetAttributes(attribute.Int64("stream.duration_ms", duration.Milliseconds()))

                // Обработка ошибок
                if err != nil </span><span class="cov1" title="1">{
                        s, _ := status.FromError(err)
                        span.SetStatus(codes.Error, s.Message())
                        span.SetAttributes(
                                attribute.String("rpc.status_code", s.Code().String()),
                                attribute.String("error.message", err.Error()),
                        )
                        span.RecordError(err)
                }</span> else<span class="cov4" title="6"> {
                        span.SetStatus(codes.Ok, "")
                        span.SetAttributes(attribute.String("rpc.status_code", "OK"))
                }</span>

                // Записываем завершение потока
                <span class="cov5" title="7">span.AddEvent("stream_ended")

                return err</span>
        }
}

// wrappedServerStream оборачивает grpc.ServerStream для использования контекста с трассировкой
type wrappedServerStream struct {
        grpc.ServerStream
        ctx context.Context
}

func (w *wrappedServerStream) Context() context.Context <span class="cov4" title="5">{
        return w.ctx
}</span>

// splitMethodName разделяет полное имя метода на имя сервиса и метода
func splitMethodName(fullMethodName string) (string, string) <span class="cov8" title="38">{
        fullMethodName = path.Clean(fullMethodName)
        if !path.IsAbs(fullMethodName) </span><span class="cov3" title="3">{
                return "unknown", "unknown"
        }</span>
        <span class="cov8" title="35">i := path.Dir(fullMethodName)
        j := path.Base(fullMethodName)
        if i == "." || i == "/" </span><span class="cov2" title="2">{
                return "unknown", j
        }</span>
        <span class="cov8" title="33">return i[1:], j</span> // удаляем начальный "/" из имени сервиса
}

// MetadataTextMapPropagator возвращает пропагатор контекста трассировки через метаданные gRPC
func MetadataTextMapPropagator() propagation.TextMapPropagator <span class="cov10" title="63">{
        return propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        )
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package std

import (
        "context"
        "fmt"
        "log/slog"
        "net"
        "sync"
        "time"

        adaptergrpc "github.com/pure-golang/adapters/grpc"
        "github.com/pure-golang/adapters/grpc/middleware"
        "github.com/pure-golang/adapters/logger"
        "github.com/pkg/errors"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/keepalive"
        "google.golang.org/grpc/reflection"
)

const ShutdownTimeout = 15 * time.Second

var _ adaptergrpc.RunableProvider = (*Server)(nil)

type Config struct {
        Host          string `envconfig:"GRPC_HOST"`
        Port          int    `envconfig:"GRPC_PORT" required:"true"`
        TLSCertPath   string `envconfig:"GRPC_TLS_CERT_PATH"`
        TLSKeyPath    string `envconfig:"GRPC_TLS_KEY_PATH"`
        EnableReflect bool   `envconfig:"GRPC_ENABLE_REFLECTION" default:"true"`
}

type ServerOption func(*Server)

type Server struct {
        logger             *slog.Logger
        server             *grpc.Server
        config             Config
        listener           net.Listener
        listenerMu         sync.RWMutex
        interceptors       []grpc.UnaryServerInterceptor
        streamInterceptors []grpc.StreamServerInterceptor
        serverOpts         []grpc.ServerOption
        monitoringOpts     *middleware.MonitoringOptions
}

func WithUnaryInterceptor(interceptor grpc.UnaryServerInterceptor) ServerOption <span class="cov4" title="5">{
        return func(s *Server) </span><span class="cov4" title="5">{
                s.interceptors = append(s.interceptors, interceptor)
        }</span>
}

func WithStreamInterceptor(interceptor grpc.StreamServerInterceptor) ServerOption <span class="cov4" title="5">{
        return func(s *Server) </span><span class="cov4" title="5">{
                s.streamInterceptors = append(s.streamInterceptors, interceptor)
        }</span>
}

func WithServerOption(opt grpc.ServerOption) ServerOption <span class="cov4" title="4">{
        return func(s *Server) </span><span class="cov4" title="4">{
                s.serverOpts = append(s.serverOpts, opt)
        }</span>
}

// WithMonitoringOptions provides custom monitoring options
// If not set, DefaultMonitoringOptions will be used
func WithMonitoringOptions(opts *middleware.MonitoringOptions) ServerOption <span class="cov4" title="4">{
        return func(s *Server) </span><span class="cov4" title="4">{
                s.monitoringOpts = opts
        }</span>
}

func NewDefault(c Config, registrationFunc func(*grpc.Server)) *Server <span class="cov2" title="2">{
        s := New(c, registrationFunc)
        return s
}</span>

func New(c Config, registrationFunc func(*grpc.Server), opts ...ServerOption) *Server <span class="cov10" title="42">{
        s := &amp;Server{
                logger:             logger.FromContext(context.Background()).WithGroup("grpcserver"),
                config:             c,
                interceptors:       []grpc.UnaryServerInterceptor{},
                streamInterceptors: []grpc.StreamServerInterceptor{},
                serverOpts:         []grpc.ServerOption{},
        }

        for _, opt := range opts </span><span class="cov7" title="18">{
                opt(s)
        }</span>

        // Настраиваем мониторинг
        <span class="cov10" title="42">monitoringOptions := s.monitoringOpts
        if monitoringOptions == nil </span><span class="cov9" title="39">{
                monitoringOptions = middleware.DefaultMonitoringOptions(s.logger)
        }</span>
        <span class="cov10" title="42">unaryInterceptors, streamInterceptors, monitoringOpts := middleware.SetupMonitoring(
                context.Background(),
                monitoringOptions,
        )

        // Добавляем пользовательские интерцепторы
        unaryInterceptors = append(unaryInterceptors, s.interceptors...)
        streamInterceptors = append(streamInterceptors, s.streamInterceptors...)

        // Настройки сервера
        serverOpts := append(monitoringOpts, s.serverOpts...)
        serverOpts = append(serverOpts,
                grpc.ChainUnaryInterceptor(unaryInterceptors...),
                grpc.ChainStreamInterceptor(streamInterceptors...),
        )

        serverOpts = append(serverOpts, grpc.KeepaliveParams(keepalive.ServerParameters{
                // ... keepalive настройки
        }))

        // Настройка TLS если необходимо
        if c.TLSCertPath != "" &amp;&amp; c.TLSKeyPath != "" </span><span class="cov2" title="2">{
                creds, err := credentials.NewServerTLSFromFile(c.TLSCertPath, c.TLSKeyPath)
                if err != nil </span><span class="cov2" title="2">{
                        s.logger.With("error", err).Error("failed to create TLS credentials")
                }</span> else<span class="cov0" title="0"> {
                        serverOpts = append(serverOpts, grpc.Creds(creds))
                }</span>
        }

        // Создаем сервер
        <span class="cov10" title="42">s.server = grpc.NewServer(serverOpts...)

        // Регистрируем сервисы
        registrationFunc(s.server)

        // Добавляем reflection API если нужно
        if c.EnableReflect </span><span class="cov4" title="4">{
                reflection.Register(s.server)
        }</span>

        <span class="cov10" title="42">return s</span>
}

func (s *Server) Start() error <span class="cov6" title="10">{
        addr := fmt.Sprintf("%s:%d", s.config.Host, s.config.Port)

        lis, err := net.Listen("tcp", addr)
        if err != nil </span><span class="cov4" title="5">{
                return errors.Wrapf(err, "failed to listen on %s", addr)
        }</span>

        <span class="cov4" title="5">s.listenerMu.Lock()
        s.listener = lis
        s.listenerMu.Unlock()

        s.logger.Info("gRPC server starting", "addr", addr)

        err = s.server.Serve(lis)
        if err != nil &amp;&amp; !errors.Is(err, net.ErrClosed) </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to serve gRPC")
        }</span>

        <span class="cov4" title="5">return nil</span>
}

func (s *Server) Close() error <span class="cov6" title="10">{
        stopped := make(chan struct{})

        go func() </span><span class="cov6" title="10">{
                s.server.GracefulStop()
                close(stopped)
        }</span>()

        <span class="cov6" title="10">ctx, cancel := context.WithTimeout(context.Background(), ShutdownTimeout)
        defer cancel()

        select </span>{
        case &lt;-stopped:<span class="cov6" title="10">
                s.logger.Info("gRPC server gracefully stopped")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.logger.Warn("gRPC server shutdown timeout exceeded, forcing stop")
                s.server.Stop()</span>
        }

        <span class="cov6" title="10">s.listenerMu.RLock()
        listener := s.listener
        s.listenerMu.RUnlock()

        if listener != nil </span><span class="cov4" title="5">{
                err := listener.Close()
                if err != nil </span><span class="cov4" title="5">{
                        return errors.Wrap(err, "failed to close listener")
                }</span>
        }

        <span class="cov4" title="5">return nil</span>
}

func (s *Server) Run() <span class="cov2" title="2">{
        go func() </span><span class="cov2" title="2">{
                err := s.Start()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.With("error", err).Error("gRPC server crashed")
                }</span>
        }()
}

// GetListener returns the server's listener in a thread-safe manner.
// This is primarily used in tests to check if the listener has been set.
func (s *Server) GetListener() net.Listener <span class="cov5" title="6">{
        s.listenerMu.RLock()
        defer s.listenerMu.RUnlock()
        return s.listener
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "bytes"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "github.com/pure-golang/adapters/logger"
        "go.opentelemetry.io/otel/metric"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/propagation"
        semconv "go.opentelemetry.io/otel/semconv/v1.12.0"
        "go.opentelemetry.io/otel/trace"
)

var (
        meter = otel.GetMeterProvider().Meter("github.com/pure-golang/adapters/httpserver/middleware")
        // nolint:errcheck // Sync OpenTelemetry instruments never return errors
        requestsCount, _       = meter.Int64Counter("http.request_count")
        requestTimeHist, _     = meter.Int64Histogram("http.request_time", metric.WithUnit("ms"))
        requestBodyLenHist, _  = meter.Int64Histogram("http.request_body_len", metric.WithUnit("KB"))
        responseBodyLenHist, _ = meter.Int64Histogram("http.response_body_len", metric.WithUnit("KB"))
        tracer                 = otel.Tracer("github.com/pure-golang/adapters/httpserver/middleware")
)

// Monitoring traces incoming http requests using open telemetry tracer + attaches logger to request context
func Monitoring(next http.Handler) http.Handler <span class="cov8" title="33">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="33">{
                reqTime := time.Now()
                ctx := r.Context()

                ctx = otel.GetTextMapPropagator().Extract(ctx, propagation.HeaderCarrier(r.Header))

                uriWithoutParameters := strings.Split(r.RequestURI, "?")[0]
                ctx, span := tracer.Start(ctx, uriWithoutParameters, trace.WithSpanKind(trace.SpanKindServer))
                defer span.End()
                metricLabels := []attribute.KeyValue{
                        attribute.String("http.method", uriWithoutParameters),
                }

                traceID := span.SpanContext().TraceID().String()

                // logger
                log := slog.Default().With(r.Method, r.RequestURI)
                if traceID != "" </span><span class="cov8" title="33">{
                        log = log.With("trace_id", traceID)
                }</span>

                // attributes
                <span class="cov8" title="33">attrs := semconv.NetAttributesFromHTTPRequest("tcp", r)
                attrs = append(attrs, semconv.EndUserAttributesFromHTTPRequest(r)...)
                attrs = append(attrs, semconv.HTTPServerAttributesFromHTTPRequest("webserver", r.RequestURI, r)...)
                attrs = append(attrs, attribute.String("http.request.header.Authorization", r.Header.Get("Authorization")))
                attrs = append(attrs, attribute.String("http.request.header.Cookie", r.Header.Get("Cookie")))
                attrs = append(attrs, attribute.String("http.request.header.User-Agent", r.Header.Get("User-Agent")))

                reqBody, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to read body", "error", err)
                }</span> else<span class="cov8" title="33"> {
                        r.Body = io.NopCloser(bytes.NewBuffer(reqBody))
                        attrs = append(attrs, attribute.String("http.request.body_2048", cut(reqBody)))
                }</span>

                <span class="cov8" title="33">w.Header().Set("X-Trace-Id", traceID)

                ctx = logger.NewContext(ctx, log)
                srw := newStatefulRespWriter(w)

                next.ServeHTTP(srw, r.WithContext(ctx))

                attrs = append(attrs, attribute.Int("http.response.status", srw.status))
                attrs = append(attrs, attribute.String("http.response.body_2048", cut(srw.body)))
                span.SetAttributes(attrs...)

                // metrics
                requestsCount.Add(ctx, 1, metric.WithAttributes(append(metricLabels,
                        attribute.Int("http.response.code", srw.status))...))
                requestTimeHist.Record(ctx, time.Since(reqTime).Milliseconds(), metric.WithAttributes(metricLabels...))
                requestBodyLenHist.Record(ctx, int64(len(reqBody))/1024, metric.WithAttributes(metricLabels...))
                responseBodyLenHist.Record(ctx, int64(len(srw.body))/1024, metric.WithAttributes(metricLabels...))
                if srw.status &gt;= 500 </span><span class="cov3" title="4">{
                        span.SetStatus(codes.Error, "")
                        return
                }</span>

                <span class="cov8" title="29">span.SetStatus(codes.Ok, "")</span>
        })
}

// statefulRespWriter keeps sent status and body after WriterHeader/Write calls
type statefulRespWriter struct {
        http.ResponseWriter
        status int
        body   []byte
}

func newStatefulRespWriter(w http.ResponseWriter) *statefulRespWriter <span class="cov8" title="39">{
        return &amp;statefulRespWriter{ResponseWriter: w}
}</span>

func (w *statefulRespWriter) WriteHeader(status int) <span class="cov8" title="37">{
        w.ResponseWriter.WriteHeader(status)
        w.status = status
}</span>

func (w *statefulRespWriter) Write(b []byte) (int, error) <span class="cov5" title="8">{
        if w.status == 0 </span><span class="cov3" title="3">{
                w.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov5" title="8">w.body = b
        return w.ResponseWriter.Write(b)</span>
}

func (w *statefulRespWriter) Flush() <span class="cov2" title="2">{
        if f, ok := w.ResponseWriter.(http.Flusher); ok </span><span class="cov2" title="2">{
                f.Flush()
        }</span>
}

const BodyMaxLen = 2048

func cut(body []byte) string <span class="cov10" title="70">{
        if length := len(body); length &gt; BodyMaxLen </span><span class="cov3" title="3">{
                return fmt.Sprintf("%s...(%d bytes)", string(body[:BodyMaxLen]), length)
        }</span>
        <span class="cov9" title="67">return string(body)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Recovery recovers panic and logs it on ERROR level. 500 http status is returned
package middleware

import (
        "net/http"
        "runtime/debug"
        "strings"

        "github.com/pure-golang/adapters/logger"
)

func Recovery(next http.Handler) http.Handler <span class="cov5" title="27">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="27">{
                defer func() </span><span class="cov5" title="27">{
                        err := recover()
                        if err == nil </span><span class="cov1" title="2">{
                                return
                        }</span>

                        <span class="cov5" title="25">rawStack := strings.ReplaceAll(string(debug.Stack()), "\t", "")
                        var stack []string
                        for _, line := range strings.Split(rawStack, "\n") </span><span class="cov10" title="596">{
                                if line != "" </span><span class="cov9" title="571">{
                                        stack = append(stack, line)
                                }</span>
                        }

                        <span class="cov5" title="25">logger.FromContext(r.Context()).
                                With("err", err).
                                With("stack", stack).
                                Error("Panic recovered from handler")
                        w.WriteHeader(http.StatusInternalServerError)</span>
                }()

                <span class="cov5" title="27">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package std

import (
        "context"
        stdErr "errors"
        "fmt"
        "log/slog"
        "net/http"
        "time"

        "github.com/pure-golang/adapters/httpserver"
        "github.com/pkg/errors"
)

const ShutdownTimeout = 15 * time.Second

var _ httpserver.RunableProvider = (*Server)(nil)

type Config struct {
        Host        string `envconfig:"WEBSERVER_HOST"`
        Port        int    `envconfig:"WEBSERVER_PORT" required:"true"`
        TLSCertPath string `envconfig:"WEBSERVER_TLS_CERT_PATH"`
        TLSKeyPath  string `envconfig:"WEBSERVER_TLS_KEY_PATH"`
        ReadTimeout string `envconfig:"WEBSERVER_READ_TIMEOUT" default:"30"`
}

type Server struct {
        logger *slog.Logger
        server *http.Server
        config Config
}

func NewDefault(c Config, h http.Handler) *Server <span class="cov1" title="1">{
        s := New(c, h)

        s.server.ErrorLog = slog.NewLogLogger(s.logger.Handler(), slog.LevelError)

        return s
}</span>

func New(c Config, h http.Handler /*ext: option functions*/) *Server <span class="cov10" title="16">{
        return &amp;Server{
                server: &amp;http.Server{
                        Addr:              fmt.Sprintf("%s:%d", c.Host, c.Port),
                        Handler:           h,
                        ReadHeaderTimeout: 10 * time.Second, // Prevent Slowloris attacks
                },
                logger: slog.Default().WithGroup("webserver"),
                config: c,
        }
}</span>

func (s *Server) Start() error <span class="cov6" title="6">{
        var err error
        s.logger.With().Info("server starting", slog.String("addr", s.server.Addr))

        if s.config.TLSCertPath == "" </span><span class="cov6" title="6">{
                err = s.server.ListenAndServe()
        }</span> else<span class="cov0" title="0"> {
                err = s.server.ListenAndServeTLS(s.config.TLSCertPath, s.config.TLSKeyPath)
        }</span>

        <span class="cov6" title="6">if err == nil || errors.Is(err, http.ErrServerClosed) </span><span class="cov4" title="3">{
                return nil
        }</span>

        <span class="cov4" title="3">return errors.Wrapf(err, "serve failed")</span>
}
func (s *Server) Close() error <span class="cov3" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), ShutdownTimeout)
        defer cancel()
        err := s.server.Shutdown(ctx)
        if err != nil </span><span class="cov0" title="0">{
                err = stdErr.Join(err, errors.Wrapf(s.server.Close(), "failed to close server"))
        }</span>

        <span class="cov3" title="2">s.logger.Info("server closed")

        return errors.Wrapf(err, "server shutdown failed")</span>
}

func (s *Server) Run() <span class="cov3" title="2">{
        go func() </span><span class="cov3" title="2">{
                err := s.Start()
                if err != nil </span><span class="cov1" title="1">{
                        s.logger.With("error", err).Error("webserver crushed")
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package kv

import (
        "context"
        "time"

        "github.com/pure-golang/adapters/env"
        "github.com/pure-golang/adapters/kv/noop"
        "github.com/pure-golang/adapters/kv/redis"
        "github.com/pkg/errors"
)

// Provider определяет тип key-value хранилища
type Provider string

const (
        ProviderRedis Provider = "redis" // Redis хранилище
        ProviderNoop  Provider = "noop"  // No-op реализация для тестов
)

// Config содержит конфигурацию для key-value хранилища
type Config struct {
        Provider Provider `envconfig:"KV_PROVIDER" default:"noop"`
        // Redis конфигурация (используется когда ProviderRedis)
        RedisAddr         string        `envconfig:"REDIS_ADDR" default:"localhost:6379"`
        RedisPassword     string        `envconfig:"REDIS_PASSWORD"`
        RedisDB           int           `envconfig:"REDIS_DB" default:"0"`
        RedisMaxRetries   int           `envconfig:"REDIS_MAX_RETRIES" default:"3"`
        RedisDialTimeout  time.Duration `envconfig:"REDIS_DIAL_TIMEOUT" default:"5s"`
        RedisReadTimeout  time.Duration `envconfig:"REDIS_READ_TIMEOUT" default:"3s"`
        RedisWriteTimeout time.Duration `envconfig:"REDIS_WRITE_TIMEOUT" default:"3s"`
        RedisPoolSize     int           `envconfig:"REDIS_POOL_SIZE" default:"10"`
}

// Store определяет интерфейс key-value хранилища
type Store interface {
        // Базовые операции
        Get(ctx context.Context, key string) (string, error)
        Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
        Delete(ctx context.Context, keys ...string) error
        Exists(ctx context.Context, keys ...string) (int64, error)

        // Операции с счётчиками
        Incr(ctx context.Context, key string) (int64, error)
        Decr(ctx context.Context, key string) (int64, error)

        // TTL операции
        Expire(ctx context.Context, key string, expiration time.Duration) error
        TTL(ctx context.Context, key string) (time.Duration, error)

        // Hash операции
        HGet(ctx context.Context, key, field string) (string, error)
        HSet(ctx context.Context, key, field string, value interface{}) error
        HGetAll(ctx context.Context, key string) (map[string]string, error)
        HDel(ctx context.Context, key string, fields ...string) error

        // List операции
        LPush(ctx context.Context, key string, values ...interface{}) error
        RPush(ctx context.Context, key string, values ...interface{}) error
        LPop(ctx context.Context, key string) (string, error)
        RPop(ctx context.Context, key string) (string, error)
        LLen(ctx context.Context, key string) (int64, error)

        // Set операции
        SAdd(ctx context.Context, key string, members ...interface{}) error
        SMembers(ctx context.Context, key string) ([]string, error)
        SIsMember(ctx context.Context, key string, member interface{}) (bool, error)
        SRem(ctx context.Context, key string, members ...interface{}) error

        // Подключение
        Ping(ctx context.Context) error
        Close() error
}

// NewDefault создаёт инстанс Store, читая конфигурацию из переменных окружения
func NewDefault() (Store, error) <span class="cov10" title="11">{
        var cfg Config
        if err := env.InitConfig(&amp;cfg); err != nil </span><span class="cov1" title="1">{
                return nil, errors.Wrap(err, "failed to init config")
        }</span>

        <span class="cov9" title="10">switch cfg.Provider </span>{
        case ProviderRedis:<span class="cov3" title="2">
                redisCfg := redis.Config{
                        Addr:         cfg.RedisAddr,
                        Password:     cfg.RedisPassword,
                        DB:           cfg.RedisDB,
                        MaxRetries:   cfg.RedisMaxRetries,
                        DialTimeout:  cfg.RedisDialTimeout,
                        ReadTimeout:  cfg.RedisReadTimeout,
                        WriteTimeout: cfg.RedisWriteTimeout,
                        PoolSize:     cfg.RedisPoolSize,
                }
                return redis.NewDefault(redisCfg)</span>
        case ProviderNoop:<span class="cov7" title="6">
                return noop.NewStore(), nil</span>
        default:<span class="cov3" title="2">
                return nil, errors.Errorf("unknown kv provider: %s", cfg.Provider)</span>
        }
}

// InitDefault создаёт и возвращает Store (для использования в main)
func InitDefault() (Store, error) <span class="cov3" title="2">{
        return NewDefault()
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package noop

import (
        "context"
        "time"
)

// Store представляет no-op реализацию key-value хранилища для тестов
type Store struct{}

// NewStore создаёт новый no-op Store
func NewStore() *Store <span class="cov10" title="7">{
        return &amp;Store{}
}</span>

// Get возвращает пустую строку без выполнения операций
func (s *Store) Get(ctx context.Context, key string) (string, error) <span class="cov6" title="3">{
        return "", nil
}</span>

// Set не выполняет операций
func (s *Store) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov6" title="3">{
        return nil
}</span>

// Delete не выполняет операций
func (s *Store) Delete(ctx context.Context, keys ...string) error <span class="cov6" title="3">{
        return nil
}</span>

// Exists возвращает 0 без выполнения операций
func (s *Store) Exists(ctx context.Context, keys ...string) (int64, error) <span class="cov6" title="3">{
        return 0, nil
}</span>

// Incr возвращает 0 без выполнения операций
func (s *Store) Incr(ctx context.Context, key string) (int64, error) <span class="cov6" title="3">{
        return 0, nil
}</span>

// Decr возвращает 0 без выполнения операций
func (s *Store) Decr(ctx context.Context, key string) (int64, error) <span class="cov6" title="3">{
        return 0, nil
}</span>

// Expire не выполняет операций
func (s *Store) Expire(ctx context.Context, key string, expiration time.Duration) error <span class="cov6" title="3">{
        return nil
}</span>

// TTL возвращает 0 без выполнения операций
func (s *Store) TTL(ctx context.Context, key string) (time.Duration, error) <span class="cov6" title="3">{
        return 0, nil
}</span>

// HGet возвращает пустую строку без выполнения операций
func (s *Store) HGet(ctx context.Context, key, field string) (string, error) <span class="cov6" title="3">{
        return "", nil
}</span>

// HSet не выполняет операций
func (s *Store) HSet(ctx context.Context, key, field string, value interface{}) error <span class="cov6" title="3">{
        return nil
}</span>

// HGetAll возвращает пустую map без выполнения операций
func (s *Store) HGetAll(ctx context.Context, key string) (map[string]string, error) <span class="cov6" title="3">{
        return make(map[string]string), nil
}</span>

// HDel не выполняет операций
func (s *Store) HDel(ctx context.Context, key string, fields ...string) error <span class="cov6" title="3">{
        return nil
}</span>

// LPush не выполняет операций
func (s *Store) LPush(ctx context.Context, key string, values ...interface{}) error <span class="cov6" title="3">{
        return nil
}</span>

// RPush не выполняет операций
func (s *Store) RPush(ctx context.Context, key string, values ...interface{}) error <span class="cov6" title="3">{
        return nil
}</span>

// LPop возвращает пустую строку без выполнения операций
func (s *Store) LPop(ctx context.Context, key string) (string, error) <span class="cov6" title="3">{
        return "", nil
}</span>

// RPop возвращает пустую строку без выполнения операций
func (s *Store) RPop(ctx context.Context, key string) (string, error) <span class="cov6" title="3">{
        return "", nil
}</span>

// LLen возвращает 0 без выполнения операций
func (s *Store) LLen(ctx context.Context, key string) (int64, error) <span class="cov6" title="3">{
        return 0, nil
}</span>

// SAdd не выполняет операций
func (s *Store) SAdd(ctx context.Context, key string, members ...interface{}) error <span class="cov6" title="3">{
        return nil
}</span>

// SMembers возвращает пустой slice без выполнения операций
func (s *Store) SMembers(ctx context.Context, key string) ([]string, error) <span class="cov6" title="3">{
        return []string{}, nil
}</span>

// SIsMember возвращает false без выполнения операций
func (s *Store) SIsMember(ctx context.Context, key string, member interface{}) (bool, error) <span class="cov6" title="3">{
        return false, nil
}</span>

// SRem не выполняет операций
func (s *Store) SRem(ctx context.Context, key string, members ...interface{}) error <span class="cov6" title="3">{
        return nil
}</span>

// Ping не выполняет операций
func (s *Store) Ping(ctx context.Context) error <span class="cov6" title="3">{
        return nil
}</span>

// Close не выполняет операций
func (s *Store) Close() error <span class="cov7" title="4">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package redis

import (
        "context"
        "time"

        "log/slog"

        "github.com/pkg/errors"
        rclient "github.com/redis/go-redis/v9"
        "go.opentelemetry.io/otel/codes"
)

// Client представляет клиент Redis
type Client struct {
        *rclient.Client
        cfg    Config
        logger *slog.Logger
}

// Connect создаёт новое подключение к Redis
func Connect(ctx context.Context, cfg Config) (*Client, error) <span class="cov6" title="17">{
        logger := newLogger(nil)
        logger.Debug("connecting to redis", "addr", cfg.Addr)

        rdb := rclient.NewClient(&amp;rclient.Options{
                Addr:            cfg.Addr,
                Password:        cfg.Password,
                DB:              cfg.DB,
                MaxRetries:      cfg.MaxRetries,
                MinRetryBackoff: cfg.MinRetryBackoff,
                MaxRetryBackoff: cfg.MaxRetryBackoff,
                DialTimeout:     cfg.DialTimeout,
                ReadTimeout:     cfg.ReadTimeout,
                WriteTimeout:    cfg.WriteTimeout,
                PoolSize:        cfg.PoolSize,
        })

        client := &amp;Client{
                Client: rdb,
                cfg:    cfg,
                logger: logger,
        }

        // Проверяем подключение
        if err := client.Ping(ctx); err != nil </span><span class="cov2" title="2">{
                return nil, errors.Wrap(err, "failed to ping redis")
        }</span>

        <span class="cov6" title="15">logger.Info("connected to redis", "addr", cfg.Addr)
        return client, nil</span>
}

// Close закрывает подключение к Redis
func (c *Client) Close() error <span class="cov6" title="20">{
        _, span := startSpan(context.Background(), "Close", "", c.cfg.DB)
        defer span.End()

        if c.Client == nil </span><span class="cov3" title="3">{
                return nil
        }</span>

        <span class="cov6" title="17">if err := c.Client.Close(); err != nil </span><span class="cov1" title="1">{
                // Игнорируем ошибку закрытия уже закрытого соединения
                if err.Error() != "redis: client is closed" </span><span class="cov0" title="0">{
                        recordError(span, err)
                        return errors.Wrap(err, "failed to close redis connection")
                }</span>
        }

        // Помечаем клиента как закрытого
        <span class="cov6" title="17">c.Client = nil
        c.logger.Debug("redis connection closed")
        return nil</span>
}

// Ping проверяет подключение к Redis
func (c *Client) Ping(ctx context.Context) error <span class="cov6" title="19">{
        ctx, span := startSpan(ctx, "Ping", "", c.cfg.DB)
        defer span.End()

        if err := c.Client.Ping(ctx).Err(); err != nil </span><span class="cov2" title="2">{
                recordError(span, err)
                return errors.Wrap(err, "failed to ping redis")
        }</span>

        <span class="cov6" title="17">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// Get получает значение по ключу
func (c *Client) Get(ctx context.Context, key string) (string, error) <span class="cov6" title="17">{
        ctx, span := startSpan(ctx, "Get", key, c.cfg.DB)
        defer span.End()

        val, err := c.Client.Get(ctx, key).Result()
        if err != nil </span><span class="cov3" title="4">{
                if err == rclient.Nil </span><span class="cov3" title="3">{
                        recordError(span, ErrKeyNotFound)
                        return "", ErrKeyNotFound
                }</span>
                <span class="cov1" title="1">recordError(span, err)
                return "", errors.Wrapf(err, "failed to get key %q", key)</span>
        }

        <span class="cov5" title="13">span.SetStatus(codes.Ok, "")
        return val, nil</span>
}

// Set устанавливает значение по ключу с опциональным TTL
func (c *Client) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov5" title="8">{
        ctx, span := startSpan(ctx, "Set", key, c.cfg.DB)
        defer span.End()

        if err := c.Client.Set(ctx, key, value, expiration).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to set key %q", key)
        }</span>

        <span class="cov5" title="8">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// Delete удаляет ключи
func (c *Client) Delete(ctx context.Context, keys ...string) error <span class="cov3" title="4">{
        ctx, span := startSpan(ctx, "Delete", "", c.cfg.DB)
        defer span.End()

        if len(keys) == 0 </span><span class="cov3" title="3">{
                return nil
        }</span>

        <span class="cov1" title="1">if err := c.Client.Del(ctx, keys...).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrap(err, "failed to delete keys")
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// Exists проверяет существование ключей
func (c *Client) Exists(ctx context.Context, keys ...string) (int64, error) <span class="cov3" title="4">{
        ctx, span := startSpan(ctx, "Exists", "", c.cfg.DB)
        defer span.End()

        if len(keys) == 0 </span><span class="cov3" title="3">{
                return 0, nil
        }</span>

        <span class="cov1" title="1">count, err := c.Client.Exists(ctx, keys...).Result()
        if err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return 0, errors.Wrap(err, "failed to check keys existence")
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return count, nil</span>
}

// Incr инкрементирует значение ключа на 1
func (c *Client) Incr(ctx context.Context, key string) (int64, error) <span class="cov10" title="102">{
        ctx, span := startSpan(ctx, "Incr", key, c.cfg.DB)
        defer span.End()

        val, err := c.Client.Incr(ctx, key).Result()
        if err != nil </span><span class="cov1" title="1">{
                recordError(span, err)
                return 0, errors.Wrapf(err, "failed to increment key %q", key)
        }</span>

        <span class="cov9" title="101">span.SetStatus(codes.Ok, "")
        return val, nil</span>
}

// Decr декрементирует значение ключа на 1
func (c *Client) Decr(ctx context.Context, key string) (int64, error) <span class="cov1" title="1">{
        ctx, span := startSpan(ctx, "Decr", key, c.cfg.DB)
        defer span.End()

        val, err := c.Client.Decr(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return 0, errors.Wrapf(err, "failed to decrement key %q", key)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return val, nil</span>
}

// Expire устанавливает TTL для ключа
func (c *Client) Expire(ctx context.Context, key string, expiration time.Duration) error <span class="cov2" title="2">{
        ctx, span := startSpan(ctx, "Expire", key, c.cfg.DB)
        defer span.End()

        if err := c.Client.Expire(ctx, key, expiration).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to set expiration for key %q", key)
        }</span>

        <span class="cov2" title="2">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// TTL получает оставшееся время жизни ключа
func (c *Client) TTL(ctx context.Context, key string) (time.Duration, error) <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "TTL", key, c.cfg.DB)
        defer span.End()

        ttl, err := c.Client.TTL(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return 0, errors.Wrapf(err, "failed to get ttl for key %q", key)
        }</span>

        <span class="cov3" title="3">span.SetStatus(codes.Ok, "")
        return ttl, nil</span>
}

// HGet получает значение поля из хеша
func (c *Client) HGet(ctx context.Context, key, field string) (string, error) <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "HGet", key, c.cfg.DB)
        defer span.End()

        val, err := c.Client.HGet(ctx, key, field).Result()
        if err != nil </span><span class="cov2" title="2">{
                if err == rclient.Nil </span><span class="cov1" title="1">{
                        recordError(span, ErrKeyNotFound)
                        return "", ErrKeyNotFound
                }</span>
                <span class="cov1" title="1">recordError(span, err)
                return "", errors.Wrapf(err, "failed to get hash field %q from key %q", field, key)</span>
        }

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return val, nil</span>
}

// HSet устанавливает значение поля в хеше
func (c *Client) HSet(ctx context.Context, key, field string, value interface{}) error <span class="cov2" title="2">{
        ctx, span := startSpan(ctx, "HSet", key, c.cfg.DB)
        defer span.End()

        if err := c.Client.HSet(ctx, key, field, value).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to set hash field %q in key %q", field, key)
        }</span>

        <span class="cov2" title="2">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// HGetAll получает все поля и значения из хеша
func (c *Client) HGetAll(ctx context.Context, key string) (map[string]string, error) <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "HGetAll", key, c.cfg.DB)
        defer span.End()

        val, err := c.Client.HGetAll(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return nil, errors.Wrapf(err, "failed to get all hash fields from key %q", key)
        }</span>

        <span class="cov3" title="3">span.SetStatus(codes.Ok, "")
        return val, nil</span>
}

// HDel удаляет поля из хеша
func (c *Client) HDel(ctx context.Context, key string, fields ...string) error <span class="cov3" title="4">{
        ctx, span := startSpan(ctx, "HDel", key, c.cfg.DB)
        defer span.End()

        if len(fields) == 0 </span><span class="cov3" title="3">{
                return nil
        }</span>

        <span class="cov1" title="1">if err := c.Client.HDel(ctx, key, fields...).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to delete hash fields from key %q", key)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// LPush добавляет значения в начало списка
func (c *Client) LPush(ctx context.Context, key string, values ...interface{}) error <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "LPush", key, c.cfg.DB)
        defer span.End()

        if len(values) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov1" title="1">if err := c.Client.LPush(ctx, key, values...).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to lpush to key %q", key)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// RPush добавляет значения в конец списка
func (c *Client) RPush(ctx context.Context, key string, values ...interface{}) error <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "RPush", key, c.cfg.DB)
        defer span.End()

        if len(values) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov1" title="1">if err := c.Client.RPush(ctx, key, values...).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to rpush to key %q", key)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// LPop получает и удаляет значение из начала списка
func (c *Client) LPop(ctx context.Context, key string) (string, error) <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "LPop", key, c.cfg.DB)
        defer span.End()

        val, err := c.Client.LPop(ctx, key).Result()
        if err != nil </span><span class="cov2" title="2">{
                if err == rclient.Nil </span><span class="cov1" title="1">{
                        recordError(span, ErrKeyNotFound)
                        return "", ErrKeyNotFound
                }</span>
                <span class="cov1" title="1">recordError(span, err)
                return "", errors.Wrapf(err, "failed to lpop from key %q", key)</span>
        }

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return val, nil</span>
}

// RPop получает и удаляет значение из конца списка
func (c *Client) RPop(ctx context.Context, key string) (string, error) <span class="cov2" title="2">{
        ctx, span := startSpan(ctx, "RPop", key, c.cfg.DB)
        defer span.End()

        val, err := c.Client.RPop(ctx, key).Result()
        if err != nil </span><span class="cov1" title="1">{
                if err == rclient.Nil </span><span class="cov1" title="1">{
                        recordError(span, ErrKeyNotFound)
                        return "", ErrKeyNotFound
                }</span>
                <span class="cov0" title="0">recordError(span, err)
                return "", errors.Wrapf(err, "failed to rpop from key %q", key)</span>
        }

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return val, nil</span>
}

// LLen получает длину списка
func (c *Client) LLen(ctx context.Context, key string) (int64, error) <span class="cov2" title="2">{
        ctx, span := startSpan(ctx, "LLen", key, c.cfg.DB)
        defer span.End()

        length, err := c.Client.LLen(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return 0, errors.Wrapf(err, "failed to get length of list %q", key)
        }</span>

        <span class="cov2" title="2">span.SetStatus(codes.Ok, "")
        return length, nil</span>
}

// SAdd добавляет члены в множество
func (c *Client) SAdd(ctx context.Context, key string, members ...interface{}) error <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "SAdd", key, c.cfg.DB)
        defer span.End()

        if len(members) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov1" title="1">if err := c.Client.SAdd(ctx, key, members...).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to sadd to key %q", key)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// SMembers получает все члены множества
func (c *Client) SMembers(ctx context.Context, key string) ([]string, error) <span class="cov3" title="4">{
        ctx, span := startSpan(ctx, "SMembers", key, c.cfg.DB)
        defer span.End()

        members, err := c.Client.SMembers(ctx, key).Result()
        if err != nil </span><span class="cov1" title="1">{
                recordError(span, err)
                return nil, errors.Wrapf(err, "failed to smembers from key %q", key)
        }</span>

        <span class="cov3" title="3">span.SetStatus(codes.Ok, "")
        return members, nil</span>
}

// SIsMember проверяет наличие элемента в множестве
func (c *Client) SIsMember(ctx context.Context, key string, member interface{}) (bool, error) <span class="cov2" title="2">{
        ctx, span := startSpan(ctx, "SIsMember", key, c.cfg.DB)
        defer span.End()

        isMember, err := c.Client.SIsMember(ctx, key, member).Result()
        if err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return false, errors.Wrapf(err, "failed to check membership in key %q", key)
        }</span>

        <span class="cov2" title="2">span.SetStatus(codes.Ok, "")
        return isMember, nil</span>
}

// SRem удаляет члены из множества
func (c *Client) SRem(ctx context.Context, key string, members ...interface{}) error <span class="cov3" title="3">{
        ctx, span := startSpan(ctx, "SRem", key, c.cfg.DB)
        defer span.End()

        if len(members) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov1" title="1">if err := c.Client.SRem(ctx, key, members...).Err(); err != nil </span><span class="cov0" title="0">{
                recordError(span, err)
                return errors.Wrapf(err, "failed to srem from key %q", key)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package redis

import (
        "context"
        "time"
)

// Config содержит конфигурацию для подключения к Redis
type Config struct {
        Addr            string        // Адрес Redis сервера (хост:порт)
        Password        string        // Пароль для подключения
        DB              int           // Номер базы данных
        MaxRetries      int           // Максимальное количество попыток повтора
        MinRetryBackoff time.Duration // Минимальная задержка между повторами
        MaxRetryBackoff time.Duration // Максимальная задержка между повторами
        DialTimeout     time.Duration // Таймаут установки соединения
        ReadTimeout     time.Duration // Таймаут чтения
        WriteTimeout    time.Duration // Таймаут записи
        PoolSize        int           // Размер пула соединений
}

// NewDefault создаёт Config с значениями по умолчанию
func NewDefault(cfg Config) (*Client, error) <span class="cov10" title="3">{
        if cfg.Addr == "" </span><span class="cov0" title="0">{
                cfg.Addr = "localhost:6379"
        }</span>
        <span class="cov10" title="3">if cfg.MaxRetries == 0 </span><span class="cov1" title="1">{
                cfg.MaxRetries = 3
        }</span>
        <span class="cov10" title="3">if cfg.MinRetryBackoff == 0 </span><span class="cov10" title="3">{
                cfg.MinRetryBackoff = 8 * time.Millisecond
        }</span>
        <span class="cov10" title="3">if cfg.MaxRetryBackoff == 0 </span><span class="cov10" title="3">{
                cfg.MaxRetryBackoff = 512 * time.Millisecond
        }</span>
        <span class="cov10" title="3">if cfg.DialTimeout == 0 </span><span class="cov1" title="1">{
                cfg.DialTimeout = 5 * time.Second
        }</span>
        <span class="cov10" title="3">if cfg.ReadTimeout == 0 </span><span class="cov1" title="1">{
                cfg.ReadTimeout = 3 * time.Second
        }</span>
        <span class="cov10" title="3">if cfg.WriteTimeout == 0 </span><span class="cov1" title="1">{
                cfg.WriteTimeout = 3 * time.Second
        }</span>
        <span class="cov10" title="3">if cfg.PoolSize == 0 </span><span class="cov1" title="1">{
                cfg.PoolSize = 10
        }</span>

        <span class="cov10" title="3">return Connect(context.Background(), cfg)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package redis

import (
        "github.com/pkg/errors"
)

// ErrKeyNotFound возвращается когда ключ не найден в Redis
var ErrKeyNotFound = errors.New("key not found")

// ErrTypeMismatch возвращается когда тип значения не соответствует ожидаемому
var ErrTypeMismatch = errors.New("type mismatch")

// Nil является обёрткой для redis.Nil
type Nil struct{}

// Error реализует интерфейс error
func (Nil) Error() string <span class="cov1" title="1">{
        return "redis: nil"
}</span>

// IsNil проверяет, является ли ошибка redis.Nil
func IsNil(err error) bool <span class="cov10" title="9">{
        return err == Nil{} || err == nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package redis

import (
        "log/slog"
)

// newLogger создаёт логгер с группой "redis"
func newLogger(base *slog.Logger) *slog.Logger <span class="cov10" title="30">{
        if base == nil </span><span class="cov10" title="30">{
                base = slog.Default()
        }</span>
        <span class="cov10" title="30">return base.WithGroup("redis")</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package redis

import (
        "context"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

var tracer = otel.Tracer("github.com/pure-golang/adapters/kv/redis")

// startSpan создаёт новый span с атрибутами ключа и базы данных
func startSpan(ctx context.Context, operation string, key string, db int) (context.Context, trace.Span) <span class="cov10" title="217">{
        attrs := []attribute.KeyValue{
                attribute.String("db.system", "redis"),
        }
        if key != "" </span><span class="cov9" title="170">{
                attrs = append(attrs, attribute.String("redis.key", key))
        }</span>
        <span class="cov10" title="217">if db &gt; 0 </span><span class="cov1" title="1">{
                attrs = append(attrs, attribute.Int("redis.db", db))
        }</span>
        <span class="cov10" title="217">return tracer.Start(ctx, "redis."+operation, trace.WithAttributes(attrs...))</span>
}

// recordError записывает ошибку в спан
func recordError(span trace.Span, err error) <span class="cov5" title="13">{
        if err != nil </span><span class="cov5" title="13">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
        }</span> else<span class="cov0" title="0"> {
                span.SetStatus(codes.Ok, "")
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package devslog

import (
        "log/slog"
        "os"

        "github.com/golang-cz/devslog"
)

func NewDefault(level slog.Level) *slog.Logger <span class="cov10" title="35">{
        opts := &amp;devslog.Options{
                HandlerOptions: &amp;slog.HandlerOptions{
                        AddSource: true,
                        Level:     level,
                },
                NewLineAfterLog:    true,
                MaxErrorStackTrace: 40,
                MaxSlicePrintSize:  40,
                SortKeys:           true,
                TimeFormat:         "[15:04:05]",
                DebugColor:         devslog.Magenta,
                StringerFormatter:  true,
        }

        return slog.New(devslog.NewHandler(os.Stdout, opts))
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package logger

import (
        "context"
        "log/slog"

        "github.com/pure-golang/adapters/logger/devslog"
        "github.com/pure-golang/adapters/logger/noop"
        "github.com/pure-golang/adapters/logger/stdjson"
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel"
)

type Level string
type Provider string
type contextKeyT string

var contextKey = contextKeyT("github.com/pure-golang/adapters/logger")

const (
        INFO  Level = "info"
        ERROR Level = "error"
        WARN  Level = "warn"
        DEBUG Level = "debug"

        ProviderDevSlog Provider = "dev"      // for dev
        ProviderStdJson Provider = "std_json" // for production
        ProviderNoop    Provider = "noop"     // for unit tests
)

type Config struct {
        Provider Provider `envconfig:"LOG_PROVIDER" default:"std_json"`
        Level    Level    `envconfig:"LOG_LEVEL" default:"info"`
}

// NewDefault creates a new instance of slog.Logger by default using Config.
func NewDefault(c Config) *slog.Logger <span class="cov6" title="21">{
        level := convertLevel(c.Level)
        switch c.Provider </span>{
        case ProviderDevSlog:<span class="cov2" title="2">
                return devslog.NewDefault(level)</span>
        case ProviderNoop:<span class="cov5" title="9">
                return noop.NewNoop()</span>
        case ProviderStdJson:<span class="cov4" title="7">
                fallthrough</span>
        default:<span class="cov5" title="10">
                return stdjson.NewDefault(level)</span>
        }
}

// InitDefault creates a new instance of slog.Logger and set it by default.
func InitDefault(c Config) <span class="cov5" title="8">{
        slog.SetDefault(NewDefault(c))
        otel.SetErrorHandler(otel.ErrorHandlerFunc(func(err error) </span><span class="cov0" title="0">{
                slog.Default().Error(err.Error())
        }</span>))
}

// FromContext pack logger into context.
func FromContext(ctx context.Context) *slog.Logger <span class="cov10" title="107">{
        if l, ok := ctx.Value(contextKey).(*slog.Logger); ok </span><span class="cov8" title="56">{
                return l
        }</span>

        <span class="cov8" title="51">return slog.Default()</span>
}

// NewContext extract logger from context if exists or return default.
func NewContext(ctx context.Context, l *slog.Logger) context.Context <span class="cov9" title="77">{
        return context.WithValue(ctx, contextKey, l)
}</span>

// WithErr return default logger with error.
func WithErr(err error) *slog.Logger <span class="cov3" title="4">{
        return appendErr(slog.Default(), err)
}</span>

// FromContextWithErr extract logger from context and attach error field.
func FromContextWithErr(ctx context.Context, err error) *slog.Logger <span class="cov3" title="3">{
        l := FromContext(ctx)
        return appendErr(l, err)
}</span>

// WithErrIf return default logger with error if err != nil.
// Otherwise no-op.
func WithErrIf(err error) *slog.Logger <span class="cov2" title="2">{
        if err == nil </span><span class="cov1" title="1">{
                return noop.NewNoop()
        }</span>

        <span class="cov1" title="1">return WithErr(err)</span>
}

// FromContextWithErrIf extract logger from context (default if not exists).
// Append error and stack trace.
// Returns no-op if err == nil.
func FromContextWithErrIf(ctx context.Context, err error) *slog.Logger <span class="cov2" title="2">{
        if err == nil </span><span class="cov1" title="1">{
                return noop.NewNoop()
        }</span>

        <span class="cov1" title="1">return FromContextWithErr(ctx, err)</span>
}

func appendErr(l *slog.Logger, err error) *slog.Logger <span class="cov5" title="9">{
        var stackTracer interface {
                StackTrace() errors.StackTrace
        }

        if errors.As(err, &amp;stackTracer) </span><span class="cov5" title="9">{
                l = l.With("stack", stackTracer.StackTrace())
        }</span>

        <span class="cov5" title="9">return l.With("error", err.Error())</span>
}

func convertLevel(level Level) slog.Level <span class="cov7" title="29">{
        switch level </span>{
        case INFO:<span class="cov6" title="16">
                return slog.LevelInfo</span>
        case ERROR:<span class="cov3" title="3">
                return slog.LevelError</span>
        case WARN:<span class="cov3" title="3">
                return slog.LevelWarn</span>
        case DEBUG:<span class="cov3" title="4">
                return slog.LevelDebug</span>
        default:<span class="cov3" title="3">
                return slog.LevelInfo</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package noop

import (
        "log/slog"
)

type writer struct {
        slog.Handler
}

func (n *writer) Write(_ []byte) (int, error) <span class="cov10" title="1197">{
        return 0, nil
}</span>

func NewNoop() *slog.Logger <span class="cov6" title="93">{
        return slog.New(slog.NewJSONHandler(new(writer), nil))
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package stdjson

import (
        "log/slog"
        "os"
)

func NewDefault(level slog.Level) *slog.Logger <span class="cov10" title="27">{
        return slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: level}))
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package noop

import (
        "context"

        "github.com/pure-golang/adapters/mail"
)

var _ mail.Sender = (*Sender)(nil)

// Sender is a no-op mail sender for testing.
type Sender struct {
        closed bool
}

// NewSender creates a new no-op Sender.
func NewSender() *Sender <span class="cov10" title="3">{
        return &amp;Sender{
                closed: false,
        }
}</span>

// Send silently discards emails.
func (n *Sender) Send(ctx context.Context, emails ...mail.Email) error <span class="cov6" title="2">{
        for _, email := range emails </span><span class="cov1" title="1">{
                _ = email // Discard
        }</span>
        <span class="cov6" title="2">return nil</span>
}

// Close is a no-op.
func (n *Sender) Close() error <span class="cov6" title="2">{
        n.closed = true
        return nil
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package smtp

import (
        "context"
        "crypto/tls"
        "fmt"
        "net"
        "net/smtp"
        "strings"
        "sync"
        "time"

        "github.com/pure-golang/adapters/mail"

        "github.com/pkg/errors"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

var _ mail.Sender = (*Sender)(nil)

// Sender implements mail.Sender using net/smtp.
type Sender struct {
        mx     sync.Mutex
        cfg    Config
        closed bool
}

// SenderOptions contains options for creating a Sender.
type SenderOptions struct {
        // Logger can be added later if needed
}

// NewSender creates a new SMTP Sender.
func NewSender(cfg Config, options *SenderOptions) *Sender <span class="cov9" title="75">{
        return &amp;Sender{
                cfg:    cfg,
                closed: false,
        }
}</span>

// Send sends one or more emails.
func (s *Sender) Send(ctx context.Context, emails ...mail.Email) error <span class="cov7" title="35">{
        for _, email := range emails </span><span class="cov7" title="35">{
                if err := s.send(ctx, email); err != nil </span><span class="cov6" title="18">{
                        return err
                }</span>
        }
        <span class="cov6" title="17">return nil</span>
}

// send sends a single email.
func (s *Sender) send(ctx context.Context, email mail.Email) error <span class="cov7" title="35">{
        ctx, span := tracer.Start(ctx, "SMTP.Send", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        // Set span attributes
        span.SetAttributes(
                attribute.String("smtp.from", email.From.Address),
                attribute.String("smtp.subject", email.Subject),
                attribute.Int("smtp.to_count", len(email.To)),
                attribute.Int("smtp.cc_count", len(email.Cc)),
                attribute.Int("smtp.bcc_count", len(email.Bcc)),
                attribute.String("smtp.host", s.cfg.Host),
                attribute.Int("smtp.port", s.cfg.Port),
                attribute.Bool("smtp.tls", s.cfg.TLS),
        )

        s.mx.Lock()
        defer s.mx.Unlock()

        if s.closed </span><span class="cov1" title="1">{
                span.SetStatus(codes.Error, "sender is closed")
                return errors.New("sender is closed")
        }</span>

        // Build email content
        <span class="cov7" title="34">from := email.From.Address
        if from == "" </span><span class="cov4" title="6">{
                from = s.cfg.From
        }</span>
        <span class="cov7" title="34">if from == "" </span><span class="cov2" title="2">{
                return errors.New("no from address specified")
        }</span>

        <span class="cov7" title="32">toAddresses := s.getEmailAddresses(email.To)
        ccAddresses := s.getEmailAddresses(email.Cc)
        bccAddresses := s.getEmailAddresses(email.Bcc)

        if len(toAddresses) == 0 &amp;&amp; len(ccAddresses) == 0 &amp;&amp; len(bccAddresses) == 0 </span><span class="cov1" title="1">{
                return errors.New("no recipients specified")
        }</span>

        // Build message
        <span class="cov7" title="31">msg := s.buildMessage(email)

        // SMTP server address
        addr := fmt.Sprintf("%s:%d", s.cfg.Host, s.cfg.Port)

        var auth smtp.Auth
        if s.cfg.Username != "" </span><span class="cov3" title="4">{
                auth = smtp.PlainAuth("", s.cfg.Username, s.cfg.Password, s.cfg.Host)
        }</span>

        <span class="cov7" title="31">var err error
        if s.cfg.TLS </span><span class="cov6" title="15">{
                err = s.sendMailWithTLS(ctx, addr, auth, from, append(toAddresses, ccAddresses...), bccAddresses, msg)
        }</span> else<span class="cov6" title="16"> {
                err = s.sendMail(ctx, addr, auth, from, append(toAddresses, ccAddresses...), bccAddresses, msg)
        }</span>

        <span class="cov7" title="31">if err != nil </span><span class="cov5" title="14">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return errors.Wrap(err, "failed to send email")
        }</span>

        <span class="cov6" title="17">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// sendMail sends email without TLS (plain connection).
func (s *Sender) sendMail(ctx context.Context, addr string, auth smtp.Auth, from string, to, bcc []string, msg []byte) error <span class="cov6" title="16">{
        ctx, span := tracer.Start(ctx, "SMTP.SendMail")
        defer span.End()

        span.SetAttributes(
                attribute.String("smtp.address", addr),
                attribute.String("smtp.from", from),
                attribute.Int("smtp.recipients_count", len(to)+len(bcc)),
                attribute.Bool("smtp.auth", auth != nil),
        )

        // Connect to server using DialContext for proper context support
        dialer := &amp;net.Dialer{}
        conn, err := dialer.DialContext(ctx, "tcp", addr)
        if err != nil </span><span class="cov4" title="6">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to connect")
                return errors.Wrap(err, "failed to connect to SMTP server")
        }</span>

        // Use hostname for SMTP client (needed for TLS verification and auth)
        <span class="cov5" title="10">hostname := s.cfg.Host
        client, err := smtp.NewClient(conn, hostname)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create SMTP client")
                return errors.Wrap(err, "failed to create SMTP client")
        }</span>
        <span class="cov5" title="10">defer func() </span><span class="cov5" title="10">{
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        _ = err
                }</span>
        }()

        // Authenticate if credentials provided
        <span class="cov5" title="10">if auth != nil </span><span class="cov0" title="0">{
                if err := client.Auth(auth); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to authenticate")
                        return errors.Wrap(err, "failed to authenticate")
                }</span>
        }

        // Set sender
        <span class="cov5" title="10">if err := client.Mail(from); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to set sender")
                return errors.Wrap(err, "failed to set sender")
        }</span>

        // Set recipients
        <span class="cov5" title="10">allRecipients := append(to, bcc...)
        for _, addr := range allRecipients </span><span class="cov5" title="13">{
                if err := client.Rcpt(addr); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to set recipient")
                        return errors.Wrapf(err, "failed to set recipient: %s", addr)
                }</span>
        }

        // Send data
        <span class="cov5" title="10">writer, err := client.Data()
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get data writer")
                return errors.Wrap(err, "failed to get data writer")
        }</span>
        <span class="cov5" title="10">defer func() </span><span class="cov5" title="10">{
                if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                        _ = err
                }</span>
        }()

        <span class="cov5" title="10">_, err = writer.Write(msg)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to write message")
                return errors.Wrap(err, "failed to write message")
        }</span>

        <span class="cov5" title="10">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// sendMailWithTLS sends email using STARTTLS.
func (s *Sender) sendMailWithTLS(ctx context.Context, addr string, auth smtp.Auth, from string, to, bcc []string, msg []byte) error <span class="cov6" title="15">{
        ctx, span := tracer.Start(ctx, "SMTP.SendWithTLS")
        defer span.End()

        span.SetAttributes(
                attribute.String("smtp.address", addr),
                attribute.String("smtp.from", from),
                attribute.Int("smtp.recipients_count", len(to)+len(bcc)),
                attribute.Bool("smtp.auth", auth != nil),
        )

        // Check for context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov3" title="3">
                span.SetStatus(codes.Error, "context canceled")
                return ctx.Err()</span>
        default:<span class="cov5" title="12"></span>
        }

        // Connect to server using DialContext for proper context support
        <span class="cov5" title="12">dialer := &amp;net.Dialer{}
        conn, err := dialer.DialContext(ctx, "tcp", addr)
        if err != nil </span><span class="cov3" title="5">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to connect")
                return errors.Wrap(err, "failed to connect to SMTP server")
        }</span>

        // Use hostname for SMTP client (needed for TLS verification and auth)
        <span class="cov4" title="7">hostname := s.cfg.Host
        client, err := smtp.NewClient(conn, hostname)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create SMTP client")
                return errors.Wrap(err, "failed to create SMTP client")
        }</span>
        <span class="cov4" title="7">defer func() </span><span class="cov4" title="7">{
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        // Error closing SMTP connection is not critical here as the message has already been sent.
                        // The connection will be cleaned up by the server.
                        _ = err // Explicitly ignore to satisfy linters
                }</span>
        }()

        // Start TLS if available
        <span class="cov4" title="7">if ok, _ := client.Extension("STARTTLS"); ok </span><span class="cov3" title="5">{
                span.SetAttributes(attribute.Bool("smtp.starttls", true))

                tlsConfig := &amp;tls.Config{
                        ServerName:         s.cfg.Host,
                        InsecureSkipVerify: s.cfg.Insecure, // #nosec G402 -- controlled by config, user's responsibility
                }
                if err := client.StartTLS(tlsConfig); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to start TLS")
                        return errors.Wrap(err, "failed to start TLS")
                }</span>
        } else<span class="cov2" title="2"> {
                span.SetAttributes(attribute.Bool("smtp.starttls", false))
        }</span>

        // Authenticate if credentials provided
        <span class="cov4" title="7">if auth != nil </span><span class="cov3" title="3">{
                if err := client.Auth(auth); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to authenticate")
                        return errors.Wrap(err, "failed to authenticate")
                }</span>
        }

        // Set sender
        <span class="cov4" title="7">if err := client.Mail(from); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to set sender")
                return errors.Wrap(err, "failed to set sender")
        }</span>

        // Set recipients
        <span class="cov4" title="7">allRecipients := append(to, bcc...)
        for _, addr := range allRecipients </span><span class="cov5" title="10">{
                if err := client.Rcpt(addr); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to set recipient")
                        return errors.Wrapf(err, "failed to set recipient: %s", addr)
                }</span>
        }

        // Send data
        <span class="cov4" title="7">writer, err := client.Data()
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get data writer")
                return errors.Wrap(err, "failed to get data writer")
        }</span>
        <span class="cov4" title="7">defer func() </span><span class="cov4" title="7">{
                if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                        // Error closing data writer is not critical as the message has already been sent.
                        _ = err // Explicitly ignore to satisfy linters
                }</span>
        }()

        <span class="cov4" title="7">_, err = writer.Write(msg)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to write message")
                return errors.Wrap(err, "failed to write message")
        }</span>

        <span class="cov4" title="7">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// buildMessage builds the raw email message.
func (s *Sender) buildMessage(email mail.Email) []byte <span class="cov8" title="46">{
        var msg strings.Builder

        // Headers
        msg.WriteString(fmt.Sprintf("From: %s\r\n", s.formatAddress(email.From)))

        if len(email.To) &gt; 0 </span><span class="cov7" title="42">{
                msg.WriteString(fmt.Sprintf("To: %s\r\n", s.formatAddressList(email.To)))
        }</span>

        <span class="cov8" title="46">if len(email.Cc) &gt; 0 </span><span class="cov5" title="9">{
                msg.WriteString(fmt.Sprintf("Cc: %s\r\n", s.formatAddressList(email.Cc)))
        }</span>

        <span class="cov8" title="46">msg.WriteString(fmt.Sprintf("Subject: %s\r\n", email.Subject))
        msg.WriteString("MIME-Version: 1.0\r\n")
        msg.WriteString(fmt.Sprintf("Date: %s\r\n", time.Now().Format(time.RFC1123Z)))

        // Add custom headers
        for k, v := range email.Headers </span><span class="cov5" title="12">{
                msg.WriteString(fmt.Sprintf("%s: %s\r\n", k, v))
        }</span>

        // Build body
        <span class="cov8" title="46">if email.HTML != "" </span><span class="cov4" title="8">{
                boundary := fmt.Sprintf("boundary_%d", time.Now().UnixNano())
                msg.WriteString(fmt.Sprintf("Content-Type: multipart/alternative; boundary=%s\r\n", boundary))
                msg.WriteString("\r\n")

                // Plain text part
                msg.WriteString(fmt.Sprintf("--%s\r\n", boundary))
                msg.WriteString("Content-Type: text/plain; charset=UTF-8\r\n\r\n")
                msg.WriteString(email.Body)
                msg.WriteString("\r\n")

                // HTML part
                msg.WriteString(fmt.Sprintf("--%s\r\n", boundary))
                msg.WriteString("Content-Type: text/html; charset=UTF-8\r\n\r\n")
                msg.WriteString(email.HTML)
                msg.WriteString("\r\n")

                msg.WriteString(fmt.Sprintf("--%s--\r\n", boundary))
        }</span> else<span class="cov7" title="38"> {
                msg.WriteString("Content-Type: text/plain; charset=UTF-8\r\n\r\n")
                msg.WriteString(email.Body)
                msg.WriteString("\r\n")
        }</span>

        <span class="cov8" title="46">return []byte(msg.String())</span>
}

// formatAddress formats a single address.
func (s *Sender) formatAddress(addr mail.Address) string <span class="cov10" title="126">{
        if addr.Name != "" </span><span class="cov6" title="22">{
                // Escape quotes in name
                escapedName := strings.ReplaceAll(addr.Name, "\"", "\\\"")
                return fmt.Sprintf("%s &lt;%s&gt;", escapedName, addr.Address)
        }</span>
        <span class="cov9" title="104">return addr.Address</span>
}

// formatAddressList formats a list of addresses.
func (s *Sender) formatAddressList(addrs []mail.Address) string <span class="cov8" title="57">{
        formatted := make([]string, len(addrs))
        for i, addr := range addrs </span><span class="cov8" title="66">{
                formatted[i] = s.formatAddress(addr)
        }</span>
        <span class="cov8" title="57">return strings.Join(formatted, ", ")</span>
}

// getEmailAddresses extracts email addresses from mail.Address slice.
func (s *Sender) getEmailAddresses(addrs []mail.Address) []string <span class="cov9" title="103">{
        result := make([]string, len(addrs))
        for i, addr := range addrs </span><span class="cov8" title="53">{
                result[i] = addr.Address
        }</span>
        <span class="cov9" title="103">return result</span>
}

// Close closes the sender.
func (s *Sender) Close() error <span class="cov7" title="34">{
        s.mx.Lock()
        defer s.mx.Unlock()

        if s.closed </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov7" title="33">s.closed = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package metrics

import (
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/pkg/errors"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

type Config struct {
        Host                  string `envconfig:"METRICS_HOST" required:"true"`
        Port                  int    `envconfig:"METRICS_PORT" required:"true"`
        HttpServerReadTimeout int    `envconfig:"METRICS_READ_TIMEOUT" default:"30"`
}

type Metrics struct {
        io.Closer
        config Config
        server *http.Server
}

func InitDefault(config Config) (io.Closer, error) <span class="cov3" title="2">{
        provider := New(config)
        if err := provider.Start(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to start metrics server")
        }</span>

        <span class="cov3" title="2">return provider, nil</span>
}

func New(config Config) *Metrics <span class="cov9" title="12">{
        return &amp;Metrics{
                config: config,
                server: NewHttpServer(config),
        }
}</span>

func (s *Metrics) Start() error <span class="cov7" title="8">{
        if err := InitPrometheus(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to init prometheus")
        }</span>

        <span class="cov7" title="8">go func() </span><span class="cov7" title="7">{
                if err := s.server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        slog.Default().Warn("metrics server failed", "error", err.Error())
                }</span>
        }()

        <span class="cov7" title="8">return nil</span>
}

func (s *Metrics) Close() error <span class="cov8" title="9">{
        return errors.Wrap(s.server.Close(), "failed to close metrics")
}</span>

func NewHttpServer(conf Config) *http.Server <span class="cov10" title="15">{
        r := http.NewServeMux()
        r.Handle("/metrics", promhttp.Handler())
        return &amp;http.Server{
                Addr:        fmt.Sprintf("%s:%d", conf.Host, conf.Port),
                Handler:     r,
                ReadTimeout: time.Duration(conf.HttpServerReadTimeout) * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package metrics

import (
        "github.com/pkg/errors"
        "go.opentelemetry.io/contrib/instrumentation/runtime"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/prometheus"
        "go.opentelemetry.io/otel/sdk/metric"
)

// InitPrometheus implements opentelemetry interfaces  and set global state
func InitPrometheus() error <span class="cov10" title="14">{
        exporter, err := prometheus.New()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create prometheus instance")
        }</span>
        <span class="cov10" title="14">provider := metric.NewMeterProvider(metric.WithReader(exporter))

        otel.SetMeterProvider(provider)

        if err := runtime.Start(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to start runtime")
        }</span>

        <span class="cov10" title="14">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package encoders

import (
        "encoding/json"

        "github.com/pkg/errors"
)

type JSON struct{}

func (JSON) Encode(i any) ([]byte, error) <span class="cov10" title="24">{
        b, err := json.Marshal(i)
        return b, errors.Wrapf(err, "marshal %T: %+v", i, i)
}</span>

func (JSON) ContentType() string <span class="cov6" title="8">{
        return "application/json"
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package encoders

import (
        "github.com/pkg/errors"
)

type Text struct{}

func (t Text) Encode(i any) ([]byte, error) <span class="cov10" title="24">{
        switch i := i.(type) </span>{
        case []byte:<span class="cov4" title="3">
                return i, nil</span>
        case string:<span class="cov9" title="18">
                return []byte(i), nil</span>
        default:<span class="cov4" title="3">
                return nil, errors.Errorf("unknown type %T to encode with %T", i, t)</span>
        }
}

func (Text) ContentType() string <span class="cov8" title="15">{
        return "text/plain"
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package kafka

import (
        "log/slog"
        "time"

        "github.com/pkg/errors"
        "github.com/segmentio/kafka-go"
)

var ErrConnectionClosed = errors.New("connection is closed")

// Dialer управляет подключением к Kafka
type Dialer struct {
        dialer *kafka.Dialer
        cfg    Config
        logger *slog.Logger
        closed bool
}

// DialerOptions содержит опции для создания Dialer
type DialerOptions struct {
        Logger *slog.Logger
}

// NewDialer создает новый Dialer для работы с Kafka
func NewDialer(cfg Config, options *DialerOptions) *Dialer <span class="cov10" title="28">{
        if options == nil </span><span class="cov10" title="28">{
                options = new(DialerOptions)
        }</span>
        <span class="cov10" title="28">if options.Logger == nil </span><span class="cov10" title="28">{
                options.Logger = slog.Default()
        }</span>
        <span class="cov10" title="28">options.Logger = options.Logger.WithGroup("kafka")

        return &amp;Dialer{
                cfg:    cfg,
                logger: options.Logger,
                dialer: &amp;kafka.Dialer{
                        Timeout:   10 * time.Second,
                        DualStack: true,
                },
        }</span>
}

// NewDefaultDialer создает Dialer с параметрами по умолчанию
func NewDefaultDialer(brokers []string) *Dialer <span class="cov1" title="1">{
        return NewDialer(Config{Brokers: brokers}, nil)
}</span>

// GetDialer возвращает базовый kafka.Dialer
func (d *Dialer) GetDialer() *kafka.Dialer <span class="cov3" title="3">{
        return d.dialer
}</span>

// Close закрывает соединение с Kafka
func (d *Dialer) Close() error <span class="cov9" title="26">{
        if d.closed </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="25">d.closed = true
        d.logger.Info("Kafka dialer closed")
        return nil</span>
}

// GetBrokers возвращает список брокеров Kafka
func (d *Dialer) GetBrokers() []string <span class="cov3" title="3">{
        return d.cfg.Brokers
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package kafka

import (
        "context"
        "sync"

        "github.com/pure-golang/adapters/queue"
        "github.com/pure-golang/adapters/queue/encoders"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/segmentio/kafka-go"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

var _ queue.Publisher = (*Publisher)(nil)

// Publisher реализует интерфейс queue.Publisher для Kafka
type Publisher struct {
        mx      sync.Mutex
        dialer  *Dialer
        cfg     PublisherConfig
        writers map[string]*kafka.Writer
        closed  bool
}

// PublisherConfig содержит параметры для Publisher
type PublisherConfig struct {
        Balancer kafka.Balancer // стратегия балансировки сообщений между партициями
        Encoder  queue.Encoder  // кодировщик сообщений (по умолчанию JSON)
}

// NewPublisher создает новый Publisher для Kafka
func NewPublisher(dialer *Dialer, cfg PublisherConfig) *Publisher <span class="cov9" title="13">{
        if cfg.Encoder == nil </span><span class="cov4" title="3">{
                cfg.Encoder = encoders.JSON{}
        }</span>
        <span class="cov9" title="13">if cfg.Balancer == nil </span><span class="cov9" title="11">{
                cfg.Balancer = &amp;kafka.LeastBytes{}
        }</span>

        <span class="cov9" title="13">return &amp;Publisher{
                dialer:  dialer,
                cfg:     cfg,
                writers: make(map[string]*kafka.Writer),
                closed:  false,
        }</span>
}

// Publish публикует сообщения в Kafka (синхронно)
func (p *Publisher) Publish(ctx context.Context, messages ...queue.Message) error <span class="cov8" title="9">{
        for _, msg := range messages </span><span class="cov9" title="11">{
                if err := p.publish(ctx, msg); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="8">return nil</span>
}

// publish публикует одно сообщение в Kafka
func (p *Publisher) publish(ctx context.Context, msg queue.Message) error <span class="cov9" title="11">{
        ctx, span := tracer.Start(ctx, "Kafka.Publish", trace.WithSpanKind(trace.SpanKindProducer))
        defer span.End()

        prop := otel.GetTextMapPropagator()

        // Кодируем тело сообщения
        body, err := msg.EncodeValue(p.cfg.Encoder)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to encode message body")
        }</span>

        // Определяем тему (используем Topic из сообщения или дефолтное значение)
        <span class="cov9" title="11">topic := msg.Topic
        if topic == "" </span><span class="cov0" title="0">{
                topic = p.dialer.cfg.Brokers[0] // fallback: используем первый брокер как дефолтный topic (не идеально, но для совместимости)
        }</span>

        // Получаем или создаем writer для темы
        <span class="cov9" title="11">writer, err := p.getWriter(topic)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        // Создаем Kafka message
        <span class="cov8" title="10">kafkaMsg := kafka.Message{
                Topic: topic,
                Key:   []byte(uuid.NewString()), // используем UUID как ключ для распределения по партициям
                Value: body,
        }

        // Копируем заголовки и добавляем трейсинг
        headers := make(map[string]string)
        for k, v := range msg.Headers </span><span class="cov3" title="2">{
                headers[k] = v
        }</span>

        // Внедряем трейсинг в заголовки
        <span class="cov8" title="10">prop.Inject(ctx, headersCarrier(headers))
        for k, v := range headers </span><span class="cov3" title="2">{
                kafkaMsg.Headers = append(kafkaMsg.Headers, kafka.Header{Key: k, Value: []byte(v)})
        }</span>

        // Устанавливаем атрибуты спана
        <span class="cov8" title="10">span.SetAttributes(
                attribute.String("topic", topic),
                attribute.String("key", string(kafkaMsg.Key)),
                attribute.Int("body_size", len(kafkaMsg.Value)),
                attribute.Int("headers_count", len(kafkaMsg.Headers)),
        )

        // Публикуем сообщение
        err = writer.WriteMessages(ctx, kafkaMsg)

        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return errors.Wrap(err, "failed to publish message to Kafka")
        }</span>

        <span class="cov8" title="10">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// getWriter возвращает или создает writer для указанной темы
func (p *Publisher) getWriter(topic string) (*kafka.Writer, error) <span class="cov9" title="11">{
        p.mx.Lock()
        defer p.mx.Unlock()

        if p.closed </span><span class="cov1" title="1">{
                return nil, errors.New("publisher is closed")
        }</span>

        <span class="cov8" title="10">if writer, exists := p.writers[topic]; exists </span><span class="cov4" title="3">{
                return writer, nil
        }</span>

        // Создаем новый writer для темы
        // НЕ указываем Topic в Writer, чтобы можно было отправлять в разные темы через один writer
        <span class="cov7" title="7">writer := &amp;kafka.Writer{
                Addr:        kafka.TCP(p.dialer.cfg.Brokers...),
                Balancer:    p.cfg.Balancer,
                Async:       false, // синхронная запись для надежности
                Logger:      kafka.LoggerFunc(p.dialer.logger.Info),
                ErrorLogger: kafka.LoggerFunc(p.dialer.logger.Error),
        }

        p.writers[topic] = writer
        return writer, nil</span>
}

// Close закрывает все writer'ы и освобождает ресурсы
func (p *Publisher) Close() error <span class="cov10" title="14">{
        p.mx.Lock()
        defer p.mx.Unlock()

        if p.closed </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov9" title="13">p.closed = true

        // Закрываем все writers
        for topic, writer := range p.writers </span><span class="cov7" title="7">{
                if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                        p.dialer.logger.With("topic", topic, "error", err.Error()).Error("failed to close writer")
                }</span>
        }

        <span class="cov9" title="13">p.writers = make(map[string]*kafka.Writer)
        p.dialer.logger.Info("Kafka publisher closed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package kafka

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/pure-golang/adapters/queue"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/segmentio/kafka-go"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

const (
        // ConsumeRetryInterval интервал между попытками переподключения
        ConsumeRetryInterval = 5 * time.Second

        // DefaultLastMessageTimeout время ожидания последнего сообщения перед переподключением
        DefaultLastMessageTimeout = time.Hour
)

var _ queue.Subscriber = (*Subscriber)(nil)

// Subscriber реализует интерфейс queue.Subscriber для Kafka
type Subscriber struct {
        topic              string
        mx                 sync.Mutex
        dialer             *Dialer
        cfg                SubscriberConfig
        groupID            string
        logger             *slog.Logger
        close              chan struct{}
        wg                 sync.WaitGroup
        reader             *kafka.Reader
        lastMessageTime    time.Time
        lastMessageTimeout time.Duration
}

// SubscriberConfig содержит параметры для Subscriber
type SubscriberConfig struct {
        Name          string        // имя потребителя (для логирования)
        PrefetchCount int           // максимальное количество сообщений, обрабатываемых одновременно
        MaxTryNum     int           // максимальное количество попыток обработки сообщения (-1 для бесконечных попыток)
        Backoff       time.Duration // время ожидания между попытками
}

// NewDefaultSubscriber создает Subscriber с параметрами по умолчанию
func NewDefaultSubscriber(dialer *Dialer, topic string) *Subscriber <span class="cov1" title="1">{
        return NewSubscriber(dialer, topic, SubscriberConfig{})
}</span>

// NewSubscriber создает новый Subscriber для Kafka
func NewSubscriber(dialer *Dialer, topic string, cfg SubscriberConfig) *Subscriber <span class="cov8" title="14">{
        if cfg.Name == "" </span><span class="cov7" title="8">{
                cfg.Name = uuid.NewString()
        }</span>
        <span class="cov8" title="14">if cfg.PrefetchCount &lt;= 0 </span><span class="cov8" title="12">{
                cfg.PrefetchCount = 1
        }</span>
        <span class="cov8" title="14">if cfg.MaxTryNum == 0 </span><span class="cov8" title="11">{
                cfg.MaxTryNum = 3
        }</span>
        <span class="cov8" title="14">if cfg.Backoff == 0 </span><span class="cov8" title="11">{
                cfg.Backoff = 5 * time.Second
        }</span>

        <span class="cov8" title="14">logger := dialer.logger.With("subscriber", cfg.Name).With("topic", topic)

        groupID := dialer.cfg.GroupID
        if groupID == "" </span><span class="cov8" title="13">{
                groupID = cfg.Name // используем имя потребителя как дефолтный group ID
        }</span>

        <span class="cov8" title="14">return &amp;Subscriber{
                topic:              topic,
                dialer:             dialer,
                cfg:                cfg,
                groupID:            groupID,
                logger:             logger,
                close:              make(chan struct{}),
                lastMessageTimeout: DefaultLastMessageTimeout,
        }</span>
}

// Listen начинает слушать сообщения из Kafka
func (s *Subscriber) Listen(handler queue.Handler) <span class="cov4" title="3">{
        s.wg.Add(1)
        defer s.wg.Done()

        s.logger.Info("listening...")

        for </span><span class="cov5" title="4">{
                needRestart, err := s.listen(handler)
                if !needRestart </span><span class="cov4" title="3">{
                        return
                }</span>

                <span class="cov1" title="1">if err != nil </span><span class="cov1" title="1">{
                        s.logger.With("error", err.Error()).Error("listen error")
                }</span>

                <span class="cov1" title="1">time.Sleep(ConsumeRetryInterval)</span>
        }
}

// listen обрабатывает сообщения из одной сессии чтения
func (s *Subscriber) listen(handler queue.Handler) (bool, error) <span class="cov5" title="4">{
        reader, err := s.getReader(s.topic)
        if err != nil </span><span class="cov0" title="0">{
                return true, errors.Wrap(err, "failed to create reader")
        }</span>
        <span class="cov5" title="4">defer s.closeReader()

        s.mx.Lock()
        s.reader = reader
        s.mx.Unlock()

        for </span><span class="cov8" title="14">{
                select </span>{
                case &lt;-s.close:<span class="cov3" title="2">
                        return false, nil</span>

                case &lt;-time.After(s.lastMessageTimeout):<span class="cov0" title="0">
                        if time.Since(s.lastMessageTime) &gt; s.lastMessageTimeout </span><span class="cov0" title="0">{
                                s.logger.Warn("timeout waiting for messages, reconnecting")
                                return true, nil
                        }</span>

                default:<span class="cov8" title="12">
                        // Используем context с timeout для операций чтения
                        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                        msg, err := s.reader.ReadMessage(ctx)
                        cancel()

                        if err != nil </span><span class="cov1" title="1">{
                                // Проверяем, была ли ошибка связана с закрытием
                                select </span>{
                                case &lt;-s.close:<span class="cov1" title="1">
                                        return false, nil</span>
                                default:<span class="cov0" title="0">
                                        return true, errors.Wrap(err, "failed to read message")</span>
                                }
                        }

                        <span class="cov8" title="11">s.lastMessageTime = time.Now()

                        // Обрабатываем сообщение с retry внутри этой сессии
                        if err := s.handleMessageWithRetry(msg, handler); err != nil </span><span class="cov1" title="1">{
                                // При ошибке в retry возвращаем true для перезапуска
                                return true, err
                        }</span>
                }
        }
}

// handleMessageWithRetry обрабатывает одно сообщение с retry в рамках одной сессии
func (s *Subscriber) handleMessageWithRetry(msg kafka.Message, handler queue.Handler) error <span class="cov8" title="11">{
        var lastErr error
        maxAttempts := s.cfg.MaxTryNum

        if maxAttempts &lt; 0 </span><span class="cov0" title="0">{
                // Бесконечные попытки - обрабатываем как одну попытку с последующим возвратом ошибки
                maxAttempts = 1
        }</span>

        // Извлекаем заголовки один раз
        <span class="cov8" title="11">headers := make(map[string]string)
        for _, h := range msg.Headers </span><span class="cov3" title="2">{
                headers[h.Key] = string(h.Value)
        }</span>

        <span class="cov8" title="11">for attempt := 1; attempt &lt;= maxAttempts; attempt++ </span><span class="cov8" title="12">{
                // Извлекаем контекст трейсинга из заголовков
                ctx := otel.GetTextMapPropagator().Extract(context.Background(), headersCarrier(headers))
                ctx, span := tracer.Start(ctx, fmt.Sprintf("Kafka.Consume.%s", msg.Topic), trace.WithSpanKind(trace.SpanKindConsumer))

                if attempt &gt; 1 </span><span class="cov1" title="1">{
                        span.SetAttributes(attribute.Int("retry_attempt", attempt))
                }</span>

                <span class="cov8" title="12">span.SetAttributes(
                        attribute.String("topic", msg.Topic),
                        attribute.Int("partition", int(msg.Partition)),
                        attribute.Int64("offset", msg.Offset),
                        attribute.Int("body_size", len(msg.Value)),
                        attribute.Int("headers_count", len(msg.Headers)),
                )

                // Создаем queue.Delivery
                delivery := queue.Delivery{
                        Headers: headers,
                        Body:    msg.Value,
                }

                // Вызываем обработчик
                shouldRetry, err := handler(ctx, delivery)

                if err == nil </span><span class="cov7" title="10">{
                        // Сообщение успешно обработано
                        span.SetStatus(codes.Ok, "")
                        span.End()
                        return nil
                }</span>

                // Сохраняем последнюю ошибку
                <span class="cov3" title="2">lastErr = err

                // Произошла ошибка
                s.logger.With("error", err.Error(), "attempt", attempt).Error("handle message error")
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                span.End()

                // Если ошибка не retry-able или это последняя попытка
                if !shouldRetry || attempt &gt;= maxAttempts </span><span class="cov1" title="1">{
                        break</span>
                }

                // Ждем перед следующей попыткой
                <span class="cov1" title="1">select </span>{
                case &lt;-s.close:<span class="cov0" title="0">
                        return errors.New("subscriber closed during retry")</span>
                case &lt;-time.After(s.cfg.Backoff):<span class="cov1" title="1"></span>
                }
        }

        // Если мы используем MaxTryNum &lt; 0 (бесконечные попытки), возвращаем ошибку для перезапуска сессии
        <span class="cov1" title="1">if s.cfg.MaxTryNum &lt; 0 </span><span class="cov0" title="0">{
                return errors.Wrap(lastErr, "message processing failed (will retry on reconnect)")
        }</span>

        // Все попытки исчерпаны, возвращаем ошибку
        <span class="cov1" title="1">return errors.Wrapf(lastErr, "message processing failed after %d attempts", maxAttempts)</span>
}

// Close останавливает потребителя и закрывает все ресурсы
func (s *Subscriber) Close() error <span class="cov9" title="16">{
        s.logger.Info("closing subscriber...")

        select </span>{
        case &lt;-s.close:<span class="cov3" title="2"></span>
                // Уже закрыт
        default:<span class="cov8" title="14">
                close(s.close)</span>
        }

        // Ждем завершения listen() сначала - он закроет reader через defer
        <span class="cov9" title="16">s.wg.Wait()

        // Закрываем reader после того, как все горутины завершились
        s.closeReader()
        s.logger.Info("subscriber closed")
        return nil</span>
}

// getReader возвращает или создает reader для указанной темы
func (s *Subscriber) getReader(topic string) (*kafka.Reader, error) <span class="cov5" title="4">{
        s.mx.Lock()
        defer s.mx.Unlock()

        if s.reader != nil </span><span class="cov0" title="0">{
                return s.reader, nil
        }</span>

        <span class="cov5" title="4">reader := kafka.NewReader(kafka.ReaderConfig{
                Brokers:        s.dialer.cfg.Brokers,
                GroupID:        s.groupID,
                Topic:          topic,
                MinBytes:       1,    // 1B - fetch immediately when any message is available
                MaxBytes:       10e6, // 10MB
                MaxWait:        1 * time.Second,
                CommitInterval: 1 * time.Second, // Автоматический коммит каждую секунду
                Logger:         kafka.LoggerFunc(s.dialer.logger.Info),
                ErrorLogger:    kafka.LoggerFunc(s.dialer.logger.Error),
        })

        return reader, nil</span>
}

// closeReader закрывает reader, если он существует
func (s *Subscriber) closeReader() <span class="cov10" title="20">{
        s.mx.Lock()
        defer s.mx.Unlock()

        if s.reader != nil </span><span class="cov5" title="4">{
                if err := s.reader.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.With("error", err.Error()).Error("failed to close reader")
                }</span>
                <span class="cov5" title="4">s.reader = nil</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package kafka

import (
        "go.opentelemetry.io/otel"
)

var tracer = otel.Tracer("github.com/pure-golang/adapters/queue/kafka")

// headersCarrier реализует propagation.TextMapCarrier для передачи трейсов через заголовки Kafka
type headersCarrier map[string]string

// Get возвращает значение заголовка по ключу
func (c headersCarrier) Get(key string) string <span class="cov10" title="8">{
        return c[key]
}</span>

// Set устанавливает значение заголовка
func (c headersCarrier) Set(key, value string) <span class="cov4" title="2">{
        c[key] = value
}</span>

// Keys возвращает список всех ключей заголовков
func (c headersCarrier) Keys() []string <span class="cov5" title="3">{
        keys := make([]string, 0, len(c))
        for k := range c </span><span class="cov4" title="2">{
                keys = append(keys, k)
        }</span>
        <span class="cov5" title="3">return keys</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package queue

import (
        "context"
        "io"
        "time"
)

// Publisher sends messages to topic of message broker.
type Publisher interface {
        Publish(ctx context.Context, msgs ...Message) error
}

// Subscriber listens messages from topic of message broker.
type Subscriber interface {
        Listen(h Handler)
        io.Closer
}

// Handler returns bool=true if error is retryable.
type Handler func(ctx context.Context, msg Delivery) (bool, error)

// Encoder converts interface{} to []byte.
type Encoder interface {
        Encode(i any) ([]byte, error)
        ContentType() string
}

// Message is used to publish messages to message broker.
type Message struct {
        Topic   string
        Headers map[string]string
        Body    any
        TTL     time.Duration
}

// EncodeValue converts Body to []byte using Encoder if Body != nil.
func (m *Message) EncodeValue(enc Encoder) ([]byte, error) <span class="cov10" title="41">{
        if m.Body == nil </span><span class="cov3" title="3">{
                return nil, nil
        }</span>
        <span class="cov9" title="38">return enc.Encode(m.Body)</span>
}

// Delivery is used to consume messages from message broker.
type Delivery struct {
        Headers map[string]string
        Body    []byte
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package rabbitmq

import (
        "time"
)

type ConstantInterval struct {
        interval time.Duration
}

func NewConstantInterval(interval time.Duration) *ConstantInterval <span class="cov6" title="6">{
        return &amp;ConstantInterval{interval: interval}
}</span>

func (c *ConstantInterval) TryNum(int) (duration time.Duration, stop bool) <span class="cov10" title="16">{
        return c.interval, false
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package rabbitmq

import (
        "log/slog"
        "sync"
        "time"

        "github.com/pkg/errors"
        amqp "github.com/rabbitmq/amqp091-go"
)

var ErrConnectionClosed = errors.New("connection is closed manually")

type Dialer struct {
        uri     string
        conn    *amqp.Connection
        options *DialerOptions
        mx      sync.Mutex
}

// RetryPolicy of dialer reconnection.
type RetryPolicy interface {
        TryNum(i int) (duration time.Duration, stop bool)
}

// DialerOptions set dialer params.
type DialerOptions struct {
        RetryPolicy RetryPolicy
        Logger      *slog.Logger
}

func NewDefaultDialer(uri string) *Dialer <span class="cov1" title="1">{
        return NewDialer(uri, nil)
}</span>

func NewDialer(uri string, options *DialerOptions) *Dialer <span class="cov9" title="32">{
        if options == nil </span><span class="cov8" title="27">{
                options = new(DialerOptions)
        }</span>
        <span class="cov9" title="32">if options.Logger == nil </span><span class="cov9" title="31">{
                options.Logger = slog.Default()
        }</span>
        <span class="cov9" title="32">options.Logger = options.Logger.WithGroup("rabbitmq")

        if options.RetryPolicy == nil </span><span class="cov9" title="30">{
                options.RetryPolicy = NewDefaultMaxInterval()
        }</span>

        <span class="cov9" title="32">return &amp;Dialer{
                uri:     uri,
                options: options,
        }</span>
}

func (d *Dialer) Connect() (err error) <span class="cov10" title="42">{
        d.options.Logger.Debug("Dialing...")

        d.mx.Lock()
        defer d.mx.Unlock()

        conn, err := amqp.DialConfig(d.uri, amqp.Config{})
        if err != nil </span><span class="cov7" title="18">{
                return errors.Wrap(err, "failed to dial")
        }</span>

        <span class="cov8" title="24">ch := conn.NotifyClose(make(chan *amqp.Error, 1))
        d.conn = conn
        d.options.Logger.Debug("Connection is stable")
        go d.handleReconnect(ch)
        return nil</span>
}

func (d *Dialer) Channel() (*amqp.Channel, error) <span class="cov9" title="29">{
        d.mx.Lock()
        defer d.mx.Unlock()

        if d.conn == nil </span><span class="cov2" title="2">{
                return nil, ErrConnectionClosed
        }</span>

        <span class="cov8" title="27">channel, err := d.conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to open channel")
        }</span>
        <span class="cov8" title="27">return channel, nil</span>
}

func (d *Dialer) Close() error <span class="cov8" title="21">{
        d.mx.Lock()
        defer d.mx.Unlock()

        if d.conn == nil </span><span class="cov3" title="3">{
                return nil
        }</span>
        <span class="cov7" title="18">if err := d.conn.Close(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to close RabbitMQ connection")
        }</span>
        <span class="cov7" title="18">d.conn = nil
        return nil</span>
}

// handleReconnect listens AMQP connection failures from go-chan and attempts to reconnect
func (d *Dialer) handleReconnect(ch chan *amqp.Error) <span class="cov8" title="24">{
        err, ok := &lt;-ch
        if !ok </span><span class="cov7" title="18">{
                d.options.Logger.Debug("Shutdown")
                return
        }</span>

        <span class="cov5" title="6">d.options.Logger.With("error", err.Error()).Warn("Disconnected")

        for i := 0; ; i++ </span><span class="cov7" title="18">{
                err := d.Connect()
                if err == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov7" title="18">sleepDuration, stop := d.options.RetryPolicy.TryNum(i)
                if stop </span><span class="cov0" title="0">{
                        d.options.Logger.With("error", err.Error()).Error("Cannot to connect to rabbitmq. Time is out")
                        return
                }</span> else<span class="cov7" title="18"> {
                        d.options.Logger.With("error", err.Error()).Error("Failed to connect")
                }</span>

                <span class="cov7" title="18">time.Sleep(sleepDuration)</span>
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package rabbitmq

import (
        "time"
)

// Default values
const (
        DefaultRetryInterval             = time.Millisecond * 100
        DefaultConnIntervalMultiplicator = 2
        DefaultMaxInterval               = time.Hour * 2
)

// NewDefaultMaxInterval returns MaxInterval with default values.
func NewDefaultMaxInterval() *MaxInterval <span class="cov10" title="30">{
        return &amp;MaxInterval{
                base:          time.Millisecond * 100,
                max:           time.Hour * 2,
                multiplicator: 2,
        }
}</span>

// NewMaxInterval creates a new  MaxInterval.
func NewMaxInterval(
        baseInterval, maxInterval time.Duration,
        intervalMultiplicator int,
) *MaxInterval <span class="cov6" title="7">{
        if baseInterval == 0 </span><span class="cov1" title="1">{
                panic("interval should not be 0")</span>
        }

        <span class="cov5" title="6">if intervalMultiplicator == 0 </span><span class="cov1" title="1">{
                panic("multiplicator should not be 0")</span>
        }

        <span class="cov5" title="5">if maxInterval == 0 </span><span class="cov1" title="1">{
                panic("max interval should not be 0")</span>
        }

        <span class="cov4" title="4">return &amp;MaxInterval{
                base:          baseInterval,
                max:           maxInterval,
                multiplicator: intervalMultiplicator,
        }</span>
}

// MaxInterval is RetryPolicy.
type MaxInterval struct {
        base          time.Duration
        max           time.Duration
        multiplicator int
}

// TryNum for use in for loop. tryNum int is number of iteration.
func (interval *MaxInterval) TryNum(tryNum int) (time.Duration, bool) <span class="cov9" title="21">{
        retryInterval := interval.base * time.Duration(tryNum*interval.multiplicator)
        if retryInterval &gt; interval.max </span><span class="cov1" title="1">{
                return 0, true
        }</span>

        <span class="cov8" title="20">return retryInterval, false</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package rabbitmq

import (
        "context"
        "strconv"
        "sync"
        "time"

        "github.com/pure-golang/adapters/queue"
        "github.com/pure-golang/adapters/queue/encoders"
        "github.com/google/uuid"
        amqp "github.com/rabbitmq/amqp091-go"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

var _ queue.Publisher = (*Publisher)(nil)

type Publisher struct {
        mx      sync.Mutex
        dialer  *Dialer
        cfg     PublisherConfig
        channel *amqp.Channel
        closed  &lt;-chan *amqp.Error
}

type DeliveryMode uint8

const (
        Transient  = DeliveryMode(amqp.Transient)
        Persistent = DeliveryMode(amqp.Persistent)
)

// PublisherConfig - config that can be passed to Publisher constructor.
type PublisherConfig struct {
        Exchange, RoutingKey string
        DeliveryMode         DeliveryMode
        Encoder              queue.Encoder
        MessageTTL           time.Duration // precision to milliseconds
}

func NewPublisher(dialer *Dialer, cfg PublisherConfig) *Publisher <span class="cov9" title="14">{
        if cfg.Encoder == nil </span><span class="cov3" title="2">{
                cfg.Encoder = encoders.JSON{}
        }</span>
        <span class="cov9" title="14">if cfg.DeliveryMode == 0 </span><span class="cov8" title="13">{
                cfg.DeliveryMode = Persistent
        }</span>

        <span class="cov9" title="14">closed := make(chan *amqp.Error, 1)
        close(closed)

        return &amp;Publisher{
                dialer: dialer,
                cfg:    cfg,
                closed: closed,
        }</span>
}

// Publish messages to queue. Method is sync.
func (p *Publisher) Publish(ctx context.Context, messages ...queue.Message) error <span class="cov9" title="15">{
        p.mx.Lock()
        select </span>{
        case &lt;-p.closed:<span class="cov8" title="12">
                channel, err := p.dialer.Channel()
                if err != nil </span><span class="cov1" title="1">{
                        defer p.mx.Unlock()
                        return err
                }</span>
                <span class="cov8" title="11">p.channel = channel
                p.closed = p.channel.NotifyClose(make(chan *amqp.Error, 1))</span>
        default:<span class="cov4" title="3"></span>
        }
        <span class="cov9" title="14">p.mx.Unlock()

        for _, msg := range messages </span><span class="cov10" title="18">{
                if err := p.publish(ctx, msg); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov9" title="14">return nil</span>
}

func (p *Publisher) publish(ctx context.Context, msg queue.Message) error <span class="cov10" title="18">{
        ctx, span := tracer.Start(ctx, "RabbitMQ", trace.WithSpanKind(trace.SpanKindProducer))
        defer span.End()
        prop := otel.GetTextMapPropagator()

        body, err := msg.EncodeValue(p.cfg.Encoder)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="18">amqpMsg := amqp.Publishing{
                ContentType:  p.cfg.Encoder.ContentType(),
                MessageId:    uuid.NewString(),
                DeliveryMode: uint8(p.cfg.DeliveryMode),
                Body:         body,
                Headers:      amqp.Table{},
        }
        for k, v := range msg.Headers </span><span class="cov5" title="4">{
                amqpMsg.Headers[k] = v
        }</span>
        <span class="cov10" title="18">if p.cfg.MessageTTL &gt; 0 </span><span class="cov1" title="1">{
                amqpMsg.Expiration = strconv.FormatInt(p.cfg.MessageTTL.Milliseconds(), 10)
        }</span>
        <span class="cov10" title="18">if msg.TTL &gt; 0 </span><span class="cov1" title="1">{
                amqpMsg.Expiration = strconv.FormatInt(msg.TTL.Milliseconds(), 10)
        }</span>

        <span class="cov10" title="18">prop.Inject(ctx, tableCarrier(amqpMsg.Headers))

        routingKey := p.cfg.RoutingKey
        if msg.Topic != "" </span><span class="cov1" title="1">{
                routingKey = msg.Topic
        }</span>

        <span class="cov10" title="18">err = p.channel.Publish(
                p.cfg.Exchange,
                routingKey,
                false,
                false,
                amqpMsg,
        )

        span.SetAttributes(
                attribute.String("id", amqpMsg.MessageId),
                attribute.String("exchange", p.cfg.Exchange),
                attribute.String("key", routingKey),
                attribute.String("body", string(amqpMsg.Body)),
        )

        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
        }</span> else<span class="cov10" title="18"> {
                span.SetStatus(codes.Ok, "")
        }</span>
        <span class="cov10" title="18">return err</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package rabbitmq

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/pure-golang/adapters/queue"
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"

        amqp "github.com/rabbitmq/amqp091-go"
)

const (
        ConsumeRetryInterval      = 5 * time.Second
        InfiniteRetriesIndicator  = -1
        KeyCountRetries           = "x-count-retries"
        DefaultLastMessageTimeout = time.Hour
)

var _ queue.Subscriber = (*Subscriber)(nil)

// Subscriber implements queue.Subscriber interface
// Handle one task per time
type Subscriber struct {
        name               string
        queueName          string
        wg                 sync.WaitGroup
        cfg                SubscriberOptions
        dialer             *Dialer
        close              chan struct{}
        logger             *slog.Logger
        lastMessageTime    time.Time
        lastMessageTimeout time.Duration
}

type SubscriberOptions struct {
        Name                     string
        PrefetchCount, MaxTryNum int
        Backoff                  time.Duration
}

func NewDefaultSubscriber(dialer *Dialer, queueName string) *Subscriber <span class="cov1" title="1">{
        return NewSubscriber(dialer, queueName, SubscriberOptions{})
}</span>

func NewSubscriber(dialer *Dialer, queueName string, cfg SubscriberOptions) *Subscriber <span class="cov2" title="9">{
        var name string
        if cfg.Name == "" </span><span class="cov2" title="9">{
                name = uuid.NewString()
        }</span>
        <span class="cov2" title="9">if cfg.MaxTryNum &lt;= 0 </span><span class="cov2" title="8">{
                cfg.MaxTryNum = 0
        }</span>
        <span class="cov2" title="9">if cfg.Backoff == 0 </span><span class="cov2" title="7">{
                cfg.Backoff = 5 * time.Second
        }</span>

        <span class="cov2" title="9">return &amp;Subscriber{
                name:               name,
                queueName:          queueName,
                dialer:             dialer,
                logger:             dialer.options.Logger.With("subscriber", name).With("queue", queueName),
                close:              make(chan struct{}),
                cfg:                cfg,
                lastMessageTimeout: DefaultLastMessageTimeout,
        }</span>
}

func (s *Subscriber) Listen(handler queue.Handler) <span class="cov1" title="2">{
        s.wg.Add(1)
        defer s.wg.Done()

        s.logger.Info("listening...")
        for </span><span class="cov1" title="2">{
                s.lastMessageTime = time.Now()
                needRestart, err := s.listen(handler)
                if !needRestart </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov1" title="2">if err != nil </span><span class="cov1" title="2">{
                        s.logger.With("error", err.Error()).Error("s.listen error")
                }</span>

                <span class="cov1" title="2">time.Sleep(ConsumeRetryInterval)</span>
        }
}

func (s *Subscriber) listen(handler queue.Handler) (bool, error) <span class="cov1" title="2">{
        channel, err := s.dialer.Channel()
        if err != nil </span><span class="cov0" title="0">{
                return true, errors.Wrap(err, "failed to make channel")
        }</span>
        <span class="cov1" title="2">defer func() </span><span class="cov1" title="2">{
                // Channel close error is not critical here as we're about to exit anyway
                // and RabbitMQ will clean up the channel on the server side
                _ = channel.Close()
        }</span>()
        <span class="cov1" title="2">notifyClose := channel.NotifyClose(make(chan *amqp.Error, 1))
        closeChannel := make(chan error, 1)
        defer close(closeChannel)
        freezeClose := s.freezeClose(closeChannel)

        if err := channel.Qos(s.cfg.PrefetchCount, 0, false); err != nil </span><span class="cov0" title="0">{
                return true, errors.Wrap(err, "failed to set prefetch count")
        }</span>

        <span class="cov1" title="2">deliveries, err := channel.Consume(
                s.queueName,
                s.cfg.Name,
                false,
                false,
                false,
                false,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return true, errors.Wrapf(err, "failed to start consuming from %q", s.queueName)
        }</span>

        <span class="cov1" title="2">for </span><span class="cov10" title="62614">{
                select </span>{
                case &lt;-s.close:<span class="cov9" title="62612">
                        if err := channel.Cancel(s.name, false); err != nil </span><span class="cov1" title="2">{
                                return true, errors.Wrapf(err, "cancel consumer %q", s.name)
                        }</span>
                case amqpErr := &lt;-notifyClose:<span class="cov0" title="0">
                        if amqpErr != nil </span><span class="cov0" title="0">{
                                return true, errors.Wrap(amqpErr, "channel is closed")
                        }</span>
                case delivery, ok := &lt;-deliveries:<span class="cov1" title="2">
                        if !ok </span><span class="cov0" title="0">{
                                // Rest of messages is drained
                                return false, nil
                        }</span>
                        <span class="cov1" title="2">if err := s.handleDelivery(channel, delivery, handler); err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                case &lt;-freezeClose:<span class="cov0" title="0">
                        s.logger.Warn("last message received. need resubscribe", "time", s.lastMessageTime.UTC())
                        return true, nil</span>
                }
        }
}

func (s *Subscriber) freezeClose(closeChanel chan error) chan struct{} <span class="cov1" title="2">{
        c := make(chan struct{}, 1)
        go func() </span><span class="cov1" title="2">{
                for </span><span class="cov1" title="2">{
                        select </span>{
                        case &lt;-time.After(s.lastMessageTimeout):<span class="cov0" title="0">
                                if time.Since(s.lastMessageTime) &gt; s.lastMessageTimeout </span><span class="cov0" title="0">{
                                        c &lt;- struct{}{}
                                        return
                                }</span>
                        case _, ok := &lt;-closeChanel:<span class="cov1" title="2">
                                if !ok </span><span class="cov1" title="2">{
                                        return
                                }</span>
                        }
                }
        }()

        <span class="cov1" title="2">return c</span>
}

func (s *Subscriber) Close() error <span class="cov2" title="4">{
        s.logger.Info("Closing subscriber...")
        close(s.close)
        s.wg.Wait()
        return nil
}</span>

func (s *Subscriber) handleDelivery(channel *amqp.Channel, delivery amqp.Delivery, handler queue.Handler) error <span class="cov1" title="2">{
        s.logger.Debug("handleDelivery")
        s.lastMessageTime = time.Now()
        ctx := otel.GetTextMapPropagator().Extract(context.Background(), tableCarrier(delivery.Headers))
        ctx, span := tracer.Start(ctx, s.queueName, trace.WithSpanKind(trace.SpanKindConsumer))
        defer span.End()

        // TODO
        //s.logger.With("trace_id", span.SpanContext().TraceID())
        //ctx = log.NewContext(ctx, logger) // pass ctx into  handler

        span.SetAttributes(
                attribute.String("id", delivery.MessageId),
                attribute.String("body", string(delivery.Body)),
                attribute.String("consumer_name", s.name),
        )

        retry, err := handler(ctx, newDelivery(delivery))
        if err == nil </span><span class="cov1" title="1">{
                if err := channel.Ack(delivery.DeliveryTag, false); err != nil </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, err.Error())
                        return errors.Wrap(err, "failed to ack")
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov1" title="1">s.logger.With("error", err.Error()).Error("Handle message")
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())

        // Reject non-retryable error immediately
        if !retry </span><span class="cov1" title="1">{
                if err := channel.Reject(delivery.DeliveryTag, false); err != nil </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, err.Error())
                        return errors.Wrap(err, "failed to reject")
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov0" title="0">headers := delivery.Headers
        if headers == nil </span><span class="cov0" title="0">{
                headers = amqp.Table{}
        }</span>
        <span class="cov0" title="0">countRetries := headers[KeyCountRetries].(int32) // 0 if not exists

        if s.cfg.MaxTryNum != InfiniteRetriesIndicator </span><span class="cov0" title="0">{
                countRetries++
                if int(countRetries) &gt;= s.cfg.MaxTryNum </span><span class="cov0" title="0">{
                        if err := channel.Reject(delivery.DeliveryTag, false); err != nil </span><span class="cov0" title="0">{
                                span.SetStatus(codes.Error, err.Error())
                                return errors.Wrap(err, "failed to reject")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov0" title="0">headers[KeyCountRetries] = countRetries
        msg := amqp.Publishing{
                MessageId:    delivery.MessageId,
                ContentType:  delivery.ContentType,
                DeliveryMode: delivery.DeliveryMode,
                Body:         delivery.Body,
                Headers:      headers,
        }
        if err := channel.Publish("", s.queueName, false, false, msg); err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                return errors.Wrap(err, "failed to publish")
        }</span>
        <span class="cov0" title="0">if err := channel.Ack(delivery.DeliveryTag, false); err != nil </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                return errors.Wrap(err, "failed to ack")
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-s.close:<span class="cov0" title="0"></span>
        case &lt;-time.After(s.cfg.Backoff):<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">return nil</span>
}

func newDelivery(msg amqp.Delivery) queue.Delivery <span class="cov2" title="4">{
        headers := make(map[string]string, len(msg.Headers))
        for k, v := range msg.Headers </span><span class="cov1" title="3">{
                headers[k] = fmt.Sprintf("%v", v)
        }</span>
        <span class="cov2" title="4">return queue.Delivery{
                Headers: headers,
                Body:    msg.Body,
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package rabbitmq

import (
        amqp "github.com/rabbitmq/amqp091-go"

        "go.opentelemetry.io/otel"

        "fmt"
)

var tracer = otel.Tracer("github.com/pure-golang/adapters/queue/rabbitmq")

// tableCarrier implements propagation.TextMapCarrier to transfer traces by AMQP protocol
type tableCarrier amqp.Table

func (c tableCarrier) Get(key string) string <span class="cov9" title="7">{
        return fmt.Sprintf("%v", c[key])
}</span>

func (c tableCarrier) Set(key, value string) <span class="cov7" title="5">{
        c[key] = value
}</span>

func (c tableCarrier) Keys() []string <span class="cov7" title="5">{
        keys := make([]string, 0, len(c))
        for k := range c </span><span class="cov10" title="8">{
                keys = append(keys, k)
        }</span>
        <span class="cov7" title="5">return keys</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package storage

import (
        "errors"
        "fmt"
)

// Common storage errors.
var (
        ErrNotFound       = errors.New("object not found")
        ErrAccessDenied   = errors.New("access denied")
        ErrBucketNotFound = errors.New("bucket not found")
)

// ErrorCode represents a storage error code.
type ErrorCode string

const (
        CodeNotFound       ErrorCode = "NotFound"
        CodeAccessDenied   ErrorCode = "AccessDenied"
        CodeBucketNotFound ErrorCode = "BucketNotFound"
        CodeInternalError  ErrorCode = "InternalError"
)

// StorageError wraps storage operation errors.
type StorageError struct {
        Code    ErrorCode
        Message string
        Err     error
        Bucket  string
        Key     string
}

func (e *StorageError) Error() string <span class="cov10" title="663">{
        if e.Err != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("storage.%s: %s (bucket=%s, key=%s): %v", e.Code, e.Message, e.Bucket, e.Key, e.Err)
        }</span>
        <span class="cov9" title="662">return fmt.Sprintf("storage.%s: %s (bucket=%s, key=%s)", e.Code, e.Message, e.Bucket, e.Key)</span>
}

func (e *StorageError) Unwrap() error <span class="cov1" title="2">{
        return e.Err
}</span>

// IsNotFound checks if error is a "not found" error.
func IsNotFound(err error) bool <span class="cov3" title="6">{
        var storageErr *StorageError
        if errors.As(err, &amp;storageErr) </span><span class="cov1" title="2">{
                return storageErr.Code == CodeNotFound
        }</span>
        <span class="cov2" title="4">return errors.Is(err, ErrNotFound)</span>
}

// IsAccessDenied checks if error is an "access denied" error.
func IsAccessDenied(err error) bool <span class="cov3" title="6">{
        var storageErr *StorageError
        if errors.As(err, &amp;storageErr) </span><span class="cov1" title="2">{
                return storageErr.Code == CodeAccessDenied
        }</span>
        <span class="cov2" title="4">return errors.Is(err, ErrAccessDenied)</span>
}

// IsBucketNotFound checks if error is a "bucket not found" error.
func IsBucketNotFound(err error) bool <span class="cov3" title="6">{
        var storageErr *StorageError
        if errors.As(err, &amp;storageErr) </span><span class="cov1" title="2">{
                return storageErr.Code == CodeBucketNotFound
        }</span>
        <span class="cov2" title="4">return errors.Is(err, ErrBucketNotFound)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package minio

import (
        "context"
        "log/slog"
        "sync"
        "time"

        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
        "github.com/pkg/errors"
)

var _ Closer = (*Client)(nil)

// Closer is the interface for closing resources.
type Closer interface {
        Close() error
}

// Client wraps minio.Client for S3-compatible storage operations.
// Supports MinIO, Yandex Cloud Storage, AWS S3, and other S3-compatible providers.
type Client struct {
        client *minio.Client
        cfg    Config
        logger *slog.Logger
        mu     sync.RWMutex
        closed bool
}

// ClientOptions contains options for client creation.
type ClientOptions struct {
        Logger *slog.Logger
}

// NewClient creates a new S3-compatible storage client.
func NewClient(cfg Config, options *ClientOptions) (*Client, error) <span class="cov9" title="22">{
        if options == nil </span><span class="cov8" title="17">{
                options = &amp;ClientOptions{}
        }</span>
        <span class="cov9" title="22">if options.Logger == nil </span><span class="cov9" title="19">{
                options.Logger = slog.Default()
        }</span>

        <span class="cov9" title="22">logger := options.Logger.WithGroup("s3")

        // Initialize minio client with static credentials
        creds := credentials.NewStaticV4(cfg.AccessKey, cfg.SecretKey, "")

        endpoint := cfg.GetEndpoint()

        // Determine secure setting: InsecureSkipVerify takes precedence
        secure := cfg.Secure
        if cfg.InsecureSkipVerify </span><span class="cov2" title="2">{
                secure = false
        }</span>

        <span class="cov9" title="22">opts := &amp;minio.Options{
                Creds:  creds,
                Region: cfg.Region,
                Secure: secure,
        }

        client, err := minio.New(endpoint, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create S3 client")
        }</span>

        // Verify connection by listing buckets
        <span class="cov9" title="22">timeout := time.Duration(cfg.Timeout) * time.Second
        if timeout == 0 </span><span class="cov8" title="17">{
                timeout = 30 * time.Second
        }</span>
        <span class="cov9" title="22">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        _, err = client.ListBuckets(ctx)
        if err != nil </span><span class="cov9" title="22">{
                return nil, errors.Wrap(err, "failed to connect to S3 storage")
        }</span>

        <span class="cov0" title="0">logger.Info("S3 client initialized", "endpoint", endpoint, "region", cfg.Region)

        return &amp;Client{
                client: client,
                cfg:    cfg,
                logger: logger,
        }, nil</span>
}

// NewDefaultClient creates a client with default options.
func NewDefaultClient(cfg Config) (*Client, error) <span class="cov5" title="5">{
        return NewClient(cfg, nil)
}</span>

// GetMinioClient returns the underlying minio.Client.
func (c *Client) GetMinioClient() *minio.Client <span class="cov4" title="3">{
        return c.client
}</span>

// Close closes the S3 client connection.
func (c *Client) Close() error <span class="cov9" title="19">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.closed </span><span class="cov5" title="5">{
                return nil
        }</span>

        <span class="cov8" title="14">c.closed = true
        c.logger.Info("S3 client closed")
        return nil</span>
}

// IsClosed returns true if the client is closed.
func (c *Client) IsClosed() bool <span class="cov10" title="25">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.closed
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package minio

import (
        "strings"

        "github.com/pure-golang/adapters/storage"
)

// toStorageError converts minio errors to storage errors.
func toStorageError(err error, bucket, key string) error <span class="cov10" title="26">{
        if err == nil </span><span class="cov4" title="3">{
                return nil
        }</span>

        <span class="cov9" title="23">errMsg := err.Error()

        // Check for specific S3 error types by error message
        // Order matters: check for more specific patterns first
        switch </span>{
        case strings.Contains(errMsg, "NoSuchBucket"):<span class="cov4" title="3">
                return &amp;storage.StorageError{
                        Code:    storage.CodeBucketNotFound,
                        Message: "bucket not found",
                        Err:     err,
                        Bucket:  bucket,
                        Key:     key,
                }</span>
        case strings.Contains(errMsg, "bucket") &amp;&amp; (strings.Contains(errMsg, "not found") || strings.Contains(errMsg, "does not exist")):<span class="cov2" title="2">
                // Error mentions both bucket and not found/does not exist
                return &amp;storage.StorageError{
                        Code:    storage.CodeBucketNotFound,
                        Message: "bucket not found",
                        Err:     err,
                        Bucket:  bucket,
                        Key:     key,
                }</span>
        case strings.Contains(errMsg, "NoSuchKey") ||
                strings.Contains(errMsg, "NotFound"):<span class="cov4" title="4">
                return &amp;storage.StorageError{
                        Code:    storage.CodeNotFound,
                        Message: "object not found",
                        Err:     err,
                        Bucket:  bucket,
                        Key:     key,
                }</span>
        case strings.Contains(errMsg, "not found") ||
                strings.Contains(errMsg, "does not exist"):<span class="cov4" title="4">
                return &amp;storage.StorageError{
                        Code:    storage.CodeNotFound,
                        Message: "object not found",
                        Err:     err,
                        Bucket:  bucket,
                        Key:     key,
                }</span>
        case strings.Contains(errMsg, "AccessDenied") ||
                strings.Contains(errMsg, "Forbidden"):<span class="cov5" title="5">
                return &amp;storage.StorageError{
                        Code:    storage.CodeAccessDenied,
                        Message: "access denied",
                        Err:     err,
                        Bucket:  bucket,
                        Key:     key,
                }</span>
        }

        // Generic error wrapping
        <span class="cov5" title="5">return &amp;storage.StorageError{
                Code:    storage.CodeInternalError,
                Message: "internal storage error",
                Err:     err,
                Bucket:  bucket,
                Key:     key,
        }</span>
}

// isNotFoundError checks if error is a "not found" type error.
func isNotFoundError(err error) bool <span class="cov8" title="14">{
        if err == nil </span><span class="cov2" title="2">{
                return false
        }</span>

        <span class="cov7" title="12">errMsg := err.Error()
        return strings.Contains(errMsg, "NoSuchKey") ||
                strings.Contains(errMsg, "NotFound") ||
                strings.Contains(errMsg, "not found") ||
                strings.Contains(errMsg, "does not exist")</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package minio

const (
        // DefaultYandexEndpoint is the default Yandex Cloud Storage endpoint.
        DefaultYandexEndpoint = "storage.yandexcloud.net"
)

// Config contains S3-compatible storage connection configuration.
// Works with MinIO, Yandex Cloud Storage, AWS S3, and other S3-compatible providers.
type Config struct {
        Endpoint           string `envconfig:"S3_ENDPOINT"`                             // S3 endpoint (e.g., "localhost:9000" for MinIO, "storage.yandexcloud.net" for Yandex)
        AccessKey          string `envconfig:"S3_ACCESS_KEY" required:"true"`           // Access key ID
        SecretKey          string `envconfig:"S3_SECRET_KEY" required:"true"`           // Secret access key
        Region             string `envconfig:"S3_REGION" default:"us-east-1"`           // Region name
        DefaultBucket      string `envconfig:"S3_BUCKET"`                               // Default bucket name
        Secure             bool   `envconfig:"S3_SECURE" default:"true"`                // Use HTTPS (default true for cloud providers)
        Timeout            int    `envconfig:"S3_TIMEOUT" default:"30"`                 // Connection timeout in seconds
        InsecureSkipVerify bool   `envconfig:"S3_INSECURE_SKIP_VERIFY" default:"false"` // Skip TLS verification (for self-signed certs)
}

// GetEndpoint returns the endpoint to use, defaulting to Yandex Cloud if not set.
// For local MinIO, you should explicitly set Endpoint to "localhost:9000".
func (c *Config) GetEndpoint() string <span class="cov10" title="28">{
        if c.Endpoint != "" </span><span class="cov9" title="24">{
                return c.Endpoint
        }</span>
        <span class="cov4" title="4">return DefaultYandexEndpoint</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package minio

import (
        "bytes"
        "context"
        "io"
        "time"

        "github.com/pure-golang/adapters/storage"
        "github.com/minio/minio-go/v7"
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// core returns the minio.Core client for low-level operations.
func (s *Storage) core() *minio.Core <span class="cov2" title="3">{
        return &amp;minio.Core{Client: s.client.client}
}</span>

// CreateMultipartUpload initiates a multipart upload.
func (s *Storage) CreateMultipartUpload(ctx context.Context, bucket, key string, opts *storage.PutOptions) (*storage.MultipartUpload, error) <span class="cov5" title="68">{
        ctx, span := tracer.Start(ctx, "S3.CreateMultipartUpload", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov2" title="4">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov5" title="68">if opts == nil </span><span class="cov4" title="59">{
                opts = &amp;storage.PutOptions{}
        }</span>

        <span class="cov5" title="68">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
        )

        // Validate client is initialized
        if _, err := s.getClient(); err != nil </span><span class="cov5" title="68">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Create multipart upload
        <span class="cov0" title="0">minioOpts := minio.PutObjectOptions{
                ContentType:  opts.ContentType,
                UserMetadata: opts.Metadata,
        }

        uploadID, err := s.core().NewMultipartUpload(ctx, bucket, key, minioOpts)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, errors.Wrapf(err, "failed to create multipart upload %s/%s", bucket, key)
        }</span>

        <span class="cov0" title="0">result := &amp;storage.MultipartUpload{
                UploadID:  uploadID,
                Key:       key,
                Bucket:    bucket,
                Initiated: time.Now(),
        }

        span.SetAttributes(
                attribute.String("upload_id", uploadID),
        )
        span.SetStatus(codes.Ok, "")

        s.logger.Debug("Multipart upload created", "bucket", bucket, "key", key, "upload_id", uploadID)
        return result, nil</span>
}

// UploadPart uploads a part in a multipart upload.
func (s *Storage) UploadPart(ctx context.Context, bucket, key, uploadID string, partNumber int32, reader io.Reader) (*storage.UploadedPart, error) <span class="cov5" title="63">{
        ctx, span := tracer.Start(ctx, "S3.UploadPart", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov1" title="2">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov5" title="63">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
                attribute.String("upload_id", uploadID),
                attribute.Int("part_number", int(partNumber)),
        )

        // Determine size of the reader
        var size int64
        type sizer interface {
                Size() int64
        }
        if sz, ok := reader.(sizer); ok </span><span class="cov5" title="63">{
                size = sz.Size()
        }</span> else<span class="cov0" title="0"> {
                // Read into buffer to get size
                buf, err := io.ReadAll(reader)
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, err.Error())
                        return nil, errors.Wrap(err, "failed to read part data")
                }</span>
                <span class="cov0" title="0">size = int64(len(buf))
                reader = bytes.NewReader(buf)</span>
        }

        // Validate client is initialized
        <span class="cov5" title="63">if _, err := s.getClient(); err != nil </span><span class="cov5" title="63">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Upload the part using Core.PutObjectPart
        <span class="cov0" title="0">putOpts := minio.PutObjectPartOptions{}
        info, err := s.core().PutObjectPart(ctx, bucket, key, uploadID, int(partNumber), reader, size, putOpts)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, errors.Wrapf(err, "failed to upload part %d of %s/%s", partNumber, bucket, key)
        }</span>

        <span class="cov0" title="0">result := &amp;storage.UploadedPart{
                PartNumber: partNumber,
                ETag:       info.ETag,
                Size:       info.Size,
        }

        span.SetAttributes(
                attribute.String("etag", info.ETag),
                attribute.Int64("size", info.Size),
        )
        span.SetStatus(codes.Ok, "")

        s.logger.Debug("Part uploaded", "bucket", bucket, "key", key, "part_number", partNumber, "size", info.Size)
        return result, nil</span>
}

// CompleteMultipartUpload completes a multipart upload.
func (s *Storage) CompleteMultipartUpload(ctx context.Context, bucket, key, uploadID string, opts *storage.CompleteMultipartUploadOptions) (*storage.ObjectInfo, error) <span class="cov4" title="55">{
        ctx, span := tracer.Start(ctx, "S3.CompleteMultipartUpload", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov1" title="2">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov4" title="55">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
                attribute.String("upload_id", uploadID),
                attribute.Int("part_count", len(opts.Parts)),
        )

        // Convert parts to minio format
        minioParts := make([]minio.CompletePart, len(opts.Parts))
        for i, p := range opts.Parts </span><span class="cov10" title="10019">{
                minioParts[i] = minio.CompletePart{
                        PartNumber: int(p.PartNumber),
                        ETag:       p.ETag,
                }
        }</span>

        // Validate client is initialized
        <span class="cov4" title="55">if _, err := s.getClient(); err != nil </span><span class="cov4" title="55">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Complete the upload using Core.CompleteMultipartUpload
        <span class="cov0" title="0">minioOpts := minio.PutObjectOptions{}
        info, err := s.core().CompleteMultipartUpload(ctx, bucket, key, uploadID, minioParts, minioOpts)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, errors.Wrapf(err, "failed to complete multipart upload %s/%s", bucket, key)
        }</span>

        // Calculate total size from uploaded parts since info.Size might be 0
        <span class="cov0" title="0">var totalSize int64
        for _, p := range opts.Parts </span><span class="cov0" title="0">{
                totalSize += p.Size
        }</span>

        // If calculated size is 0 or info.Size is non-zero, use info.Size
        <span class="cov0" title="0">if totalSize == 0 &amp;&amp; info.Size &gt; 0 </span><span class="cov0" title="0">{
                totalSize = info.Size
        }</span>

        // Get object stat to fetch accurate metadata
        <span class="cov0" title="0">client, err := s.getClient()
        if err != nil </span><span class="cov0" title="0">{
                // If client validation fails, return the info we have
                result := &amp;storage.ObjectInfo{
                        Key:          key,
                        Size:         totalSize,
                        ETag:         info.ETag,
                        ContentType:  "",
                        LastModified: info.LastModified,
                }
                span.SetAttributes(
                        attribute.Int64("size", totalSize),
                        attribute.String("etag", info.ETag),
                )
                span.SetStatus(codes.Ok, "")
                s.logger.Info("Multipart upload completed", "bucket", bucket, "key", key, "size", totalSize)
                return result, nil
        }</span>

        <span class="cov0" title="0">stat, err := client.StatObject(ctx, bucket, key, minio.StatObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                // If stat fails, use the info we have
                result := &amp;storage.ObjectInfo{
                        Key:          key,
                        Size:         totalSize,
                        ETag:         info.ETag,
                        ContentType:  "",
                        LastModified: info.LastModified,
                }
                span.SetAttributes(
                        attribute.Int64("size", totalSize),
                        attribute.String("etag", info.ETag),
                )
                span.SetStatus(codes.Ok, "")
                s.logger.Info("Multipart upload completed", "bucket", bucket, "key", key, "size", totalSize)
                return result, nil
        }</span>

        <span class="cov0" title="0">result := &amp;storage.ObjectInfo{
                Key:          key,
                Size:         stat.Size,
                ETag:         stat.ETag,
                ContentType:  stat.ContentType,
                LastModified: stat.LastModified,
                Metadata:     stat.UserMetadata,
        }

        span.SetAttributes(
                attribute.Int64("size", stat.Size),
                attribute.String("etag", stat.ETag),
        )
        span.SetStatus(codes.Ok, "")

        s.logger.Info("Multipart upload completed", "bucket", bucket, "key", key, "size", stat.Size)
        return result, nil</span>
}

// AbortMultipartUpload aborts a multipart upload.
func (s *Storage) AbortMultipartUpload(ctx context.Context, bucket, key, uploadID string) error <span class="cov4" title="54">{
        ctx, span := tracer.Start(ctx, "S3.AbortMultipartUpload", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov1" title="2">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov4" title="54">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
                attribute.String("upload_id", uploadID),
        )

        // Validate client is initialized
        if _, err := s.getClient(); err != nil </span><span class="cov4" title="54">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">err := s.core().AbortMultipartUpload(ctx, bucket, key, uploadID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return errors.Wrapf(err, "failed to abort multipart upload %s/%s", bucket, key)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "")
        s.logger.Debug("Multipart upload aborted", "bucket", bucket, "key", key, "upload_id", uploadID)
        return nil</span>
}

// ListMultipartUploads lists active multipart uploads.
func (s *Storage) ListMultipartUploads(ctx context.Context, bucket string) ([]storage.MultipartUpload, error) <span class="cov0" title="0">{
        ctx, span := tracer.Start(ctx, "S3.ListMultipartUploads", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov0" title="0">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String("bucket", bucket),
        )

        // Use the minio client's ListIncompleteUploads with recursive=true
        // This uses the high-level API which should be more reliable
        ch := s.client.client.ListIncompleteUploads(ctx, bucket, "", true)

        var uploads []storage.MultipartUpload
        for upload := range ch </span><span class="cov0" title="0">{
                if upload.Err != nil </span><span class="cov0" title="0">{
                        span.RecordError(upload.Err)
                        span.SetStatus(codes.Error, upload.Err.Error())
                        return nil, errors.Wrap(upload.Err, "failed to list multipart uploads")
                }</span>

                <span class="cov0" title="0">uploads = append(uploads, storage.MultipartUpload{
                        UploadID:  upload.UploadID,
                        Key:       upload.Key,
                        Bucket:    bucket,
                        Initiated: upload.Initiated,
                })</span>
        }

        <span class="cov0" title="0">s.logger.Debug("ListMultipartUploads result", "bucket", bucket, "upload_count", len(uploads))

        span.SetAttributes(
                attribute.Int("upload_count", len(uploads)),
        )
        span.SetStatus(codes.Ok, "")

        return uploads, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package minio

import (
        "context"
        "net/url"
        "time"

        "github.com/pure-golang/adapters/storage"
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// GetPresignedURL generates a presigned URL for S3 object access.
func (s *Storage) GetPresignedURL(ctx context.Context, bucket, key string, opts *storage.PresignedURLOptions) (string, error) <span class="cov10" title="66">{
        ctx, span := tracer.Start(ctx, "S3.GetPresignedURL", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov3" title="3">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov10" title="66">if opts == nil </span><span class="cov1" title="1">{
                opts = &amp;storage.PresignedURLOptions{
                        Method: "GET",
                        Expiry: 15 * time.Minute,
                }
        }</span>

        <span class="cov10" title="66">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
                attribute.String("method", opts.Method),
                attribute.Int("expiry_seconds", int(opts.Expiry.Seconds())),
        )

        // Set default expiry
        if opts.Expiry == 0 </span><span class="cov3" title="3">{
                opts.Expiry = 15 * time.Minute
        }</span>

        // Set default method
        <span class="cov10" title="66">if opts.Method == "" </span><span class="cov2" title="2">{
                opts.Method = "GET"
        }</span>

        <span class="cov10" title="66">var presignedURL *url.URL
        var err error

        // Validate method first (before client validation)
        if opts.Method != "GET" &amp;&amp; opts.Method != "PUT" </span><span class="cov6" title="15">{
                err = errors.Errorf("unsupported HTTP method: %s", opts.Method)
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return "", err
        }</span>

        // Validate client is initialized before generating presigned URL
        <span class="cov9" title="51">client, clientErr := s.getClient()
        if clientErr != nil </span><span class="cov9" title="51">{
                span.RecordError(clientErr)
                span.SetStatus(codes.Error, clientErr.Error())
                return "", clientErr
        }</span>

        <span class="cov0" title="0">switch opts.Method </span>{
        case "GET":<span class="cov0" title="0">
                presignedURL, err = client.PresignedGetObject(ctx, bucket, key, opts.Expiry, nil)</span>
        case "PUT":<span class="cov0" title="0">
                presignedURL, err = client.PresignedPutObject(ctx, bucket, key, opts.Expiry)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return "", errors.Wrapf(err, "failed to generate presigned URL for %s/%s", bucket, key)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "")
        s.logger.Debug("Presigned URL generated", "bucket", bucket, "key", key, "method", opts.Method, "expiry", opts.Expiry)

        return presignedURL.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package minio

import (
        "context"
        "io"
        "log/slog"
        "strings"

        "github.com/pure-golang/adapters/storage"
        "github.com/minio/minio-go/v7"
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

var _ storage.Storage = (*Storage)(nil)

var tracer = otel.Tracer("github.com/pure-golang/adapters/storage/s3")

// Storage implements storage.Storage interface for S3-compatible storage.
// Supports MinIO, Yandex Cloud Storage, AWS S3, and other S3-compatible providers.
type Storage struct {
        client *Client
        cfg    Config
        logger *slog.Logger
}

// StorageOptions contains options for Storage creation.
type StorageOptions struct {
        Logger *slog.Logger
}

// NewStorage creates a new S3 Storage instance.
func NewStorage(client *Client, opts *StorageOptions) *Storage <span class="cov7" title="123">{
        if opts == nil </span><span class="cov7" title="119">{
                opts = &amp;StorageOptions{}
        }</span>
        <span class="cov7" title="123">if opts.Logger == nil </span><span class="cov7" title="121">{
                opts.Logger = slog.Default()
        }</span>

        <span class="cov7" title="123">return &amp;Storage{
                client: client,
                cfg:    client.cfg,
                logger: opts.Logger.WithGroup("storage").With("backend", "s3"),
        }</span>
}

// NewDefault creates a Storage with a new client.
func NewDefault(cfg Config) (*Storage, error) <span class="cov1" title="2">{
        client, err := NewDefaultClient(cfg)
        if err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewStorage(client, nil), nil</span>
}

// getClient returns the underlying minio client with validation.
func (s *Storage) getClient() (*minio.Client, error) <span class="cov10" title="579">{
        if s.client == nil || s.client.client == nil </span><span class="cov9" title="578">{
                return nil, &amp;storage.StorageError{
                        Code:    storage.CodeInternalError,
                        Message: "minio client is not initialized",
                }
        }</span>
        <span class="cov1" title="1">return s.client.client, nil</span>
}

// Put stores an object in S3-compatible storage.
func (s *Storage) Put(ctx context.Context, bucket, key string, reader io.Reader, opts *storage.PutOptions) error <span class="cov7" title="92">{
        ctx, span := tracer.Start(ctx, "S3.Put", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if opts == nil </span><span class="cov7" title="70">{
                opts = &amp;storage.PutOptions{}
        }</span>

        // Set default bucket if not specified
        <span class="cov7" title="92">if bucket == "" </span><span class="cov2" title="3">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov7" title="92">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
                attribute.String("content_type", opts.ContentType),
        )

        // Convert storage.PutOptions to minio.PutObjectOptions
        minioOpts := minio.PutObjectOptions{
                ContentType:  opts.ContentType,
                UserMetadata: opts.Metadata,
        }

        // Get the minio client
        client, err := s.getClient()
        if err != nil </span><span class="cov7" title="92">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        // Upload the object
        <span class="cov0" title="0">info, err := client.PutObject(ctx, bucket, key, reader, -1, minioOpts)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return errors.Wrapf(err, "failed to put object %s/%s", bucket, key)
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.Int64("size", info.Size),
                attribute.String("etag", info.ETag),
        )
        span.SetStatus(codes.Ok, "")

        s.logger.Debug("Object stored", "bucket", bucket, "key", key, "size", info.Size)
        return nil</span>
}

// Get retrieves an object from S3-compatible storage.
func (s *Storage) Get(ctx context.Context, bucket, key string) (io.ReadCloser, *storage.ObjectInfo, error) <span class="cov6" title="68">{
        ctx, span := tracer.Start(ctx, "S3.Get", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov2" title="4">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov6" title="68">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
        )

        // Get the minio client
        client, err := s.getClient()
        if err != nil </span><span class="cov6" title="68">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, nil, err
        }</span>

        // Get the object
        <span class="cov0" title="0">obj, err := client.GetObject(ctx, bucket, key, minio.GetObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, nil, toStorageError(err, bucket, key)
        }</span>

        // Get object info to return metadata
        <span class="cov0" title="0">stat, err := obj.Stat()
        if err != nil </span><span class="cov0" title="0">{
                closeErr := obj.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.With("error", closeErr).Error("failed to close object after stat error")
                }</span>
                <span class="cov0" title="0">span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, nil, toStorageError(err, bucket, key)</span>
        }

        <span class="cov0" title="0">info := &amp;storage.ObjectInfo{
                Key:          key,
                Size:         stat.Size,
                LastModified: stat.LastModified,
                ETag:         stat.ETag,
                ContentType:  stat.ContentType,
                Metadata:     stat.UserMetadata,
        }

        span.SetAttributes(
                attribute.Int64("size", stat.Size),
                attribute.String("etag", stat.ETag),
        )
        span.SetStatus(codes.Ok, "")

        return obj, info, nil</span>
}

// Delete removes an object from S3-compatible storage.
func (s *Storage) Delete(ctx context.Context, bucket, key string) error <span class="cov6" title="41">{
        ctx, span := tracer.Start(ctx, "S3.Delete", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov2" title="3">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov6" title="41">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
        )

        // Get the minio client
        client, err := s.getClient()
        if err != nil </span><span class="cov6" title="41">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">err = client.RemoveObject(ctx, bucket, key, minio.RemoveObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return toStorageError(err, bucket, key)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "")
        s.logger.Debug("Object deleted", "bucket", bucket, "key", key)
        return nil</span>
}

// Exists checks if an object exists in S3-compatible storage.
func (s *Storage) Exists(ctx context.Context, bucket, key string) (bool, error) <span class="cov6" title="54">{
        ctx, span := tracer.Start(ctx, "S3.Exists", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov2" title="4">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov6" title="54">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("key", key),
        )

        // Get the minio client
        client, err := s.getClient()
        if err != nil </span><span class="cov6" title="54">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">_, err = client.StatObject(ctx, bucket, key, minio.StatObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if isNotFoundError(err) </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Ok, "")
                        return false, nil
                }</span>
                <span class="cov0" title="0">span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return false, toStorageError(err, bucket, key)</span>
        }

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "")
        return true, nil</span>
}

// List lists objects in the specified bucket.
func (s *Storage) List(ctx context.Context, bucket string, opts *storage.ListOptions) (*storage.ListResult, error) <span class="cov5" title="30">{
        ctx, span := tracer.Start(ctx, "S3.List", trace.WithSpanKind(trace.SpanKindClient))
        defer span.End()

        if bucket == "" </span><span class="cov2" title="3">{
                bucket = s.cfg.DefaultBucket
        }</span>

        <span class="cov5" title="30">if opts == nil </span><span class="cov4" title="9">{
                opts = &amp;storage.ListOptions{}
        }</span>

        <span class="cov5" title="30">span.SetAttributes(
                attribute.String("bucket", bucket),
                attribute.String("prefix", opts.Prefix),
                attribute.Bool("recursive", opts.Recursive),
        )

        // Convert storage.ListOptions to minio.ListObjectsOptions
        minioOpts := minio.ListObjectsOptions{
                Prefix:       opts.Prefix,
                Recursive:    opts.Recursive,
                MaxKeys:      opts.MaxKeys,
                WithMetadata: true,
        }

        // Get the minio client
        client, err := s.getClient()
        if err != nil </span><span class="cov5" title="30">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // List objects
        <span class="cov0" title="0">objectCh := client.ListObjects(ctx, bucket, minioOpts)

        var objects []storage.ObjectInfo

        for object := range objectCh </span><span class="cov0" title="0">{
                if object.Err != nil </span><span class="cov0" title="0">{
                        span.RecordError(object.Err)
                        span.SetStatus(codes.Error, object.Err.Error())
                        return nil, errors.Wrap(object.Err, "failed to list objects")
                }</span>

                // Skip directory markers (objects ending with "/" with size 0)
                <span class="cov0" title="0">if strings.HasSuffix(object.Key, "/") &amp;&amp; object.Size == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">objects = append(objects, storage.ObjectInfo{
                        Key:          object.Key,
                        Size:         object.Size,
                        LastModified: object.LastModified,
                        ETag:         object.ETag,
                        ContentType:  object.ContentType,
                        Metadata:     object.UserMetadata,
                })</span>
        }

        <span class="cov0" title="0">result := &amp;storage.ListResult{
                Objects:     objects,
                IsTruncated: false, // minio-go v7 doesn't provide this info directly
        }

        span.SetAttributes(
                attribute.Int("object_count", len(objects)),
        )
        span.SetStatus(codes.Ok, "")

        return result, nil</span>
}

// Close closes the storage connection.
func (s *Storage) Close() error <span class="cov3" title="7">{
        return s.client.Close()
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package jaeger

import (
        "context"
        "fmt"

        "github.com/pure-golang/adapters/tracing"
        "github.com/pkg/errors"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/sdk/resource"
        tracesdk "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.12.0"
)

var _ tracing.Provider = (*Provider)(nil)

type Config struct {
        EndPoint    string `envconfig:"TRACING_ENDPOINT" required:"true"`
        ServiceName string `envconfig:"SERVICE_NAME" required:"true"`
        AppVersion  string `envconfig:"APP_VERSION" required:"true"`
}

// Provider extends tracesdk.TraceProvider based on jaeger.Exporter
type Provider struct {
        *tracesdk.TracerProvider
}

func (j *Provider) Close() error <span class="cov8" title="4">{
        ctx := context.Background()
        if err := j.ForceFlush(ctx); err != nil </span><span class="cov0" title="0">{
                // Ensure shutdown is called even if ForceFlush fails
                shutdownErr := j.TracerProvider.Shutdown(ctx)
                if shutdownErr != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "jaeger force flush failed (also shutdown failed)")
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, "jaeger force flush failed")</span>
        }
        <span class="cov8" title="4">err := j.TracerProvider.Shutdown(ctx)

        return errors.Wrap(err, "shutdown jaeger")</span>
}

func NewProviderBuilder(conf Config) func() (tracing.Provider, error) <span class="cov10" title="5">{
        return func() (tracing.Provider, error) </span><span class="cov10" title="5">{
                if conf.EndPoint == "" </span><span class="cov4" title="2">{
                        return nil, errors.New("empty connection string")
                }</span>
                <span class="cov7" title="3">if conf.ServiceName == "" </span><span class="cov1" title="1">{
                        return nil, errors.New("service name is empty")
                }</span>

                <span class="cov4" title="2">exp, err := otlptrace.New(
                        context.Background(),
                        otlptracehttp.NewClient(
                                otlptracehttp.WithEndpointURL(conf.EndPoint),
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create jaeger instance: %v", err)
                }</span>
                <span class="cov4" title="2">tp := tracesdk.NewTracerProvider(
                        tracesdk.WithBatcher(exp),
                        tracesdk.WithResource(resource.NewWithAttributes(
                                semconv.SchemaURL,
                                semconv.ServiceNameKey.String(conf.ServiceName),
                                semconv.ServiceVersionKey.String(conf.AppVersion),
                        )),
                        tracesdk.WithSampler(tracesdk.AlwaysSample()),
                )

                return &amp;Provider{TracerProvider: tp}, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package tracing

import (
        "io"

        "github.com/pkg/errors"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/propagation"
        tracesdk "go.opentelemetry.io/otel/sdk/trace"
        "go.opentelemetry.io/otel/trace"
)

type Provider interface {
        trace.TracerProvider
        io.Closer
}

// ProviderBuilder wrap all realization details of constructor (ex. config struct)
type ProviderBuilder func() (Provider, error)

func Init(creator ProviderBuilder) (Provider, error) <span class="cov10" title="4">{
        var provider Provider
        provider, err := creator()
        if err != nil </span><span class="cov5" title="2">{
                provider = &amp;NoopProvider{}
        }</span> else<span class="cov5" title="2"> {
                otel.SetTracerProvider(provider)
                otel.SetTextMapPropagator(propagation.TraceContext{})
        }</span>

        <span class="cov10" title="4">return provider, errors.Wrapf(err, "failed to load tracing provider")</span>
}

type NoopProvider struct{ *tracesdk.TracerProvider }

func (NoopProvider) Close() error <span class="cov1" title="1">{ return nil }</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
